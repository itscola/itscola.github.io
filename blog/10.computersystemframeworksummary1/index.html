<!DOCTYPE html>
<html><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Java and C# developer.">
    <meta name="Author" content="White_cola">
    <meta name="keywords" content="白可乐的博客,White_cola Blog,white_cola,white_cola mcbbs">
    <link rel="stylesheet" href=https://itscola.github.io/css/syntax.css>
    <link rel="stylesheet" href=https://itscola.github.io/css/style.css>
    <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
    <title>White_cola Blog</title>
  </head><body><aside id="sidenav">
    <header>
    
        <a href=https://itscola.github.io/><img src="https://itscola.github.io/avatar.png" alt="avatar"></a>
        
    

    <a id="branding" href=https://itscola.github.io/>
        
            White_cola Blog
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/"
                
            >
                <i class="fas fa-home fa-sm"></i>
                <span>主页</span>
            </a>
        
            		
            <a href="/blog/"
                
            >
                <i class="blog"></i>
                <span>博客</span>
            </a>
        
            		
            <a href="/tags"
                
            >
                <i class="tags"></i>
                <span>标签</span>
            </a>
        
            		
            <a href="https://github.com/itscola"
                
                    target="_blank"
                
            >
                <i class="github"></i>
                <span>github</span>
            </a>
        
            		
            <a href="/tags/machine-learning/"
                
            >
                <i class="MachineLearning"></i>
                <span>机器学习</span>
            </a>
        
            		
            <a href="/tags/computersystemframework/"
                
            >
                <i class="ComputerSystemFramework"></i>
                <span>计算机系统结构</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
            <div class="content">
    
    <h1 id="title">计算机系统结构总结(一)</h1>
    
      
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一-计算机系统层次结构">一 计算机系统层次结构</a>
      <ul>
        <li><a href="#1-机器级的概念">1. 机器级的概念</a></li>
        <li><a href="#2-分级意义">2. 分级意义</a></li>
        <li><a href="#3-机器级的实现">3. 机器级的实现</a></li>
        <li><a href="#4机器级的特点">4.机器级的特点</a></li>
      </ul>
    </li>
    <li><a href="#二-计算机系统结构的概念">二 计算机系统结构的概念</a>
      <ul>
        <li><a href="#1-透明度">1. 透明度</a></li>
        <li><a href="#2-系统结构">2. 系统结构</a></li>
        <li><a href="#3-计算机系统结构">3. 计算机系统结构</a></li>
      </ul>
    </li>
    <li><a href="#三-计算机的组成和实现以及它们之间的关系">三 计算机的组成和实现以及它们之间的关系</a>
      <ul>
        <li><a href="#1-计算机组成">1. 计算机组成</a></li>
        <li><a href="#2-计算机实现">2. 计算机实现</a></li>
        <li><a href="#3-计算机系统-结构-组成-实现-的关系和影响">3. 计算机系统 结构 组成 实现 的关系和影响</a></li>
      </ul>
    </li>
    <li><a href="#四-计算机系统软硬件取舍与定量设计">四 计算机系统软硬件取舍与定量设计</a>
      <ul>
        <li><a href="#1-软硬件取舍">1. 软硬件取舍</a></li>
        <li><a href="#2-取舍原则">2. 取舍原则</a></li>
        <li><a href="#3-定量设计原理">3. 定量设计原理</a></li>
      </ul>
    </li>
    <li><a href="#四-计算机性能描述使用者角度">四 》计算机性能描述（使用者角度）</a>
      <ul>
        <li><a href="#1-主频">1. 主频</a></li>
        <li><a href="#2-每秒百万条指令-mips">2. 每秒百万条指令 MIPS</a></li>
        <li><a href="#3-每秒百万条浮点指令mflops">3. 每秒百万条浮点指令（MFLOPS）</a></li>
        <li><a href="#4-真实程序运行实现">4. 真实程序运行实现</a></li>
      </ul>
    </li>
    <li><a href="#四-计算机系统设计的主要方法">四 》计算机系统设计的主要方法</a>
      <ul>
        <li><a href="#1-主要任务">1. 主要任务</a></li>
        <li><a href="#2-计算机设计的主要方法">2. 计算机设计的主要方法</a></li>
      </ul>
    </li>
    <li><a href="#五-软件-器件-硬件的发展对计算机系统结构的影响">五 软件 器件 硬件的发展对计算机系统结构的影响</a>
      <ul>
        <li><a href="#1-软件的发展对计算机系统结构的影响">1. 软件的发展对计算机系统结构的影响</a></li>
        <li><a href="#2-应用的发展对系统结构的影响">2. 应用的发展对系统结构的影响</a></li>
        <li><a href="#3-器件的发展对系统结构的影响">3. 器件的发展对系统结构的影响</a></li>
      </ul>
    </li>
    <li><a href="#六-系统结构的并行性">六 系统结构的并行性</a>
      <ul>
        <li><a href="#1-并行性">1. 并行性</a></li>
        <li><a href="#2-并行性等级划分">2. 并行性等级划分</a></li>
        <li><a href="#3-沿3种并行性开发途径的多机系列类型和特点">3. 沿3种并行性开发途径的多机系列类型和特点</a></li>
        <li><a href="#4-耦合度">4. 耦合度</a></li>
        <li><a href="#5-flynn分类法">5. Flynn分类法</a></li>
      </ul>
    </li>
  </ul>
</nav>
    <hr>
<p>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解<strong>计算机系统结构</strong>。 如果你正在学这门科目，那这个系列将非常适合你。</p>
<p>这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。</p>
<p>这个系列并不是普通的“笔记”，<strong>不同的是，我会用尽可能简洁通俗的语言来讲解。</strong></p>
<p><a href="https://whitecola.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"><!-- raw HTML omitted -->计算机系统结构系列<!-- raw HTML omitted --></a></p>
<p><strong>欢迎来到这个系列的第一章的最后一篇文章，这一篇，将总结从1.1-1.5-2的所有内容。</strong></p>
<p><strong>这篇文章是之前的总结，不会进行任何概念上的讲解。</strong></p>
<p><strong>这篇文章是之前的总结，不会进行任何概念上的讲解。</strong></p>
<p><strong>这篇文章是之前的总结，不会进行任何概念上的讲解。</strong></p>
<p><img src="/ComputerSystem/Summary1.png" alt="image"></p>
<h2 id="一-计算机系统层次结构">一 计算机系统层次结构</h2>
<p>计算机系统分了几层，每一层我们称之为“机器级”。</p>
<h3 id="1-机器级的概念">1. 机器级的概念</h3>
<p>计算机系统按照从高级到低级，分成6层，分别为 <strong>应用语言机器级、高级语言机器级、汇编语言机器级、操作系统机器级、传统机器语言机器级、微程序机器级</strong>。</p>
<h3 id="2-分级意义">2. 分级意义</h3>
<p>在分级的情况下，任意一级的下级机器级，我们都是不太用关注的，但确实客观存在的。</p>
<p>机器级可以简化系统逻辑，但也会带来不可控制的问题。</p>
<h3 id="3-机器级的实现">3. 机器级的实现</h3>
<p>机器级通过 翻译 或 解释 再或是两种豆使用，来实现机器级之间的交互。</p>
<p>翻译：先用转换程序，将上一级机器级的程序翻译为下一级机器级上的等价的程序，然后在下一级机器级继续实现。</p>
<p>解释：用低一级的机器级上的一串语句或指令来仿真高级机器级上的一条语句或指令功能。</p>
<p>特点：<br>
翻译技术是先翻译然后执行。   效率较高。
解释技术是一边解释一遍运行。更灵活，当效率较低。</p>
<h3 id="4机器级的特点">4.机器级的特点</h3>
<ol>
<li>应用语言程序，通过程序包翻译成高级语言程序。</li>
<li>高级语言程序通过编译程序，翻译成汇编语言程序。</li>
<li>汇编语言程序通过汇编器，翻译成机器语言程序。</li>
<li>操作系统通过机器语言程序解释控制语句作业。</li>
<li>传统语言机器级（固件），通过微指令程序解释指令。</li>
<li>微程序机器级（硬件）通过微指令系统直接执行微指令。</li>
</ol>
<h2 id="二-计算机系统结构的概念">二 计算机系统结构的概念</h2>
<h3 id="1-透明度">1. 透明度</h3>
<p>概念：一些客观存在的事物或属性，在某一角度看不到，那么我们说这些事物或属性对于这一角度是透明的。</p>
<p>作用：</p>
<ol>
<li>简化所在机器级的设计。（好处）</li>
<li>带来无法控制的问题。（坏处）</li>
</ol>
<h3 id="2-系统结构">2. 系统结构</h3>
<p>概念：系统结构是对各机器级上的界面的定义，和上下级功能分配。</p>
<p>研究：系统结构研究各机器级上，哪些是透明的，哪些是不透明的。</p>
<h3 id="3-计算机系统结构">3. 计算机系统结构</h3>
<p>概念：计算机系统结构又称计算机体系结构，是系统结构的一部分。指的就是 传统机器语言机器级 的结构。</p>
<p>在它之上是 操作系统机器级 汇编语言机器级 高级语言机器级 应用语言机器级，在它之下是固件和硬件，所以它是软件和硬件的交界面。</p>
<p>是汇编语言程序设计或编译语言程序设计者所看到的抽象概念。</p>
<p>研究：</p>
<ol>
<li>传统语言机器级上界面的定义。</li>
<li>软件和硬件的功能分配。</li>
<li>为各级之间的正常运作，提供应有，看得见，应遵守的规范。</li>
</ol>
<h2 id="三-计算机的组成和实现以及它们之间的关系">三 计算机的组成和实现以及它们之间的关系</h2>
<h3 id="1-计算机组成">1. 计算机组成</h3>
<p>概念：计算机组成是计算机系统结构的逻辑实现。包括内部的控制流，数据流的组成，逻辑设计等。</p>
<p>着眼于 机器级内部各事件的排序方式，控制结构，各部件的功能及联系。</p>
<p>它对于计算机系统结构是透明的。</p>
<p>研究：如何在一定的资金和性能下，做到更好更合理的组成计算机，实现所需系统结构。</p>
<h3 id="2-计算机实现">2. 计算机实现</h3>
<p>概念：计算机实现是计算机组成的物理实现。</p>
<p>对于计算机系统结构也是透明时。</p>
<p>研究：器件技术（主导） 和 微组装技术。</p>
<h3 id="3-计算机系统-结构-组成-实现-的关系和影响">3. 计算机系统 结构 组成 实现 的关系和影响</h3>
<p>相互关系：</p>
<ol>
<li>它们互不相同，却互相影响。</li>
<li>一种计算机系统机构可以有多种组成方式。</li>
<li>一种组成方式可以有多种实现。</li>
</ol>
<p>相互影响：</p>
<ol>
<li>计算机组成向上决定于系统结构，向下受限与计算机实现技术。应当在所需条件下，在计算机组成和计算机实现之间权衡。【权衡】</li>
<li>计算机组成也会影响计算机系统结构，没有计算机组成等进步，就没有计算机系统结构的进步。【进步】</li>
<li>计算机系统结构不但要考虑上级的算法，软件，界面的支持。还要考虑下级，所采用或准备采用等计算机组成和实现技术。【上下考虑】</li>
<li>不同时期不同系统，结构，组成，实现 会有所差异。在一个系统中作为系统结构的内容，在另一个系统中可能作为组成和实现的内容。【不同时间差异】</li>
</ol>
<h2 id="四-计算机系统软硬件取舍与定量设计">四 计算机系统软硬件取舍与定量设计</h2>
<h3 id="1-软硬件取舍">1. 软硬件取舍</h3>
<p>成本方面考虑：<br>
概念：</p>
<ol>
<li>一个功能即可以用软件实现，也可以用硬件实现。</li>
<li>用软件实现更灵活，更强大，成本更低，但效率较低。</li>
<li>用硬件实现成本较高，但效率更搞。</li>
<li>软件的成本可以是硬件成本的100倍。</li>
</ol>
<p>结论：</p>
<ol>
<li>当一个功能大量出现，才更适合用硬件实现。</li>
<li>当设备生产量较大，使用硬件的比例高越划算。</li>
<li>不能什么都用硬件，要考虑成本等问题问。</li>
</ol>
<h3 id="2-取舍原则">2. 取舍原则</h3>
<ol>
<li>在现有的硬器件条件下，应从费用，速度等其它性能综合考虑，以获得高的性能价格比。【性能价格比】</li>
<li>应从采用或将采用的组成技术考虑，使其不要过多不合理的限制组成和实现技术。【组成技术不限制】</li>
<li>不能光从 硬 的角度去考虑如何便于组成技术的成功 和 发挥器件技术的发展。还要从 软的角度去考虑，如何为 编译程序和操作系统，以及高级语言程序的设计提供更多硬件支持，放在首位。【硬软考虑】</li>
</ol>
<h3 id="3-定量设计原理">3. 定量设计原理</h3>
<p>哈夫曼压缩法：<br>
更专注于优化出现频率更高的事件。</p>
<p>阿姆达尔定律：</p>
<ol>
<li>计算加速比。</li>
<li>要对计算机有效的加速，应更注重整体的加速。</li>
</ol>
<p>程序访问的局限性：<br>
分为空间局限性 和 时间局限性。<br>
指令在空间局部性的体现是 代码顺序，在时间局部性的体现是循环语句。<br>
数据再空间局部性的体现是 字符串 数组，时间局部性体现是 变量，数据。</p>
<h2 id="四-计算机性能描述使用者角度">四 》计算机性能描述（使用者角度）</h2>
<h3 id="1-主频">1. 主频</h3>
<p>主频作为性能描述的指标是不靠谱的。<br>
主频高的cpu不一定比主频低的cpu性能好，说不定只是主频高的cpu核心数更多。</p>
<p>在核心数等条件相同下，是可以用主频进行比较。</p>
<h3 id="2-每秒百万条指令-mips">2. 每秒百万条指令 MIPS</h3>
<p><del>单位时间内，执行指令越多，性能越好。</del></p>
<p>MIPS = 执行条数 / 执行时间 * 10^6</p>
<p>这也是不靠谱的，可能一个游戏的功能，用硬件只需要100条指令，用软件需要10000条指令。</p>
<p>硬件实现100条指令的，不一定比软件10000条指令的差。</p>
<h3 id="3-每秒百万条浮点指令mflops">3. 每秒百万条浮点指令（MFLOPS）</h3>
<p>就是MIPS的精准版，用的是小数，MIPS同的整数。</p>
<p>超级计算机比赛就用这个指标，因为执行的指令等条件都一样。</p>
<h3 id="4-真实程序运行实现">4. 真实程序运行实现</h3>
<p>唯一靠谱指标。</p>
<p>多个计算机同时做一个任务，谁先完成的早，谁性能最好。</p>
<p>为了防止计算机有各自擅长的领域。通常多个领域都测试一遍，然后看结果。</p>
<h2 id="四-计算机系统设计的主要方法">四 》计算机系统设计的主要方法</h2>
<h3 id="1-主要任务">1. 主要任务</h3>
<p>计算机系统设计的主要任务是计算机的 结构 组成 实现。</p>
<h3 id="2-计算机设计的主要方法">2. 计算机设计的主要方法</h3>
<ol>
<li>从上往下<br>
由顶向底设计<br>
先按照应用的需求，设计好应用的虚拟机器级的环境和特征。再逐级向下设计。</li>
</ol>
<ul>
<li>每设计下一级，都要考虑对上一级的优化。</li>
<li>要串行设计，设计周期长。</li>
<li>应用的环境和特征是多变的，一旦变化，系统将不适应。</li>
<li>传统机器级和微程序机器级通常选择已有的，不单独设计。</li>
<li>实际很难优化。</li>
</ul>
<ol start="2">
<li>从下往上<br>
由底向顶设计<br>
先按照现有的传统机器级和微程序机器级结构设计，再去适配应用。</li>
</ol>
<ul>
<li>同样串行设计，设计周期长。</li>
<li>有时只需要简单点更改硬件，就能对应用做出很大的优化，这个做不到。</li>
<li>软硬件脱节，应用得不到硬件的支持变得繁杂。</li>
</ul>
<ol start="3">
<li>从中间向两边<br>
由中间向两边设计，通用机常用方法。</li>
</ol>
<ul>
<li>同时向上下设计，可减少设计周期。</li>
<li>设计时，上下双方可沟通，做简单调整适配。</li>
<li>不存在软硬件脱节问题。</li>
</ul>
<h2 id="五-软件-器件-硬件的发展对计算机系统结构的影响">五 软件 器件 硬件的发展对计算机系统结构的影响</h2>
<h3 id="1-软件的发展对计算机系统结构的影响">1. 软件的发展对计算机系统结构的影响</h3>
<p>可移植性：程序由一台计算机，无需修改或只需要简单的修改，就可以移植到另一台计算机。</p>
<p>可移植性特点：</p>
<ol>
<li>软件能长期使用，不会因为机器更新而需要重写。【无需重写】</li>
<li>大大减少了编程软件的工作量。【减少编程软件工作量】</li>
<li>能迅速用上新的硬件技术，更新系统，让新系统立即发挥效能。【新系统发挥效能】</li>
<li>软件设计者将更有精力开发全新的软件。【软件设计者更有精力】</li>
</ol>
<p>实现可移植性的几种方法：</p>
<ol>
<li>模拟和仿真</li>
<li>采用系列机</li>
<li>统一高级语言</li>
</ol>
<p>一 模拟和仿真</p>
<p>模拟：通过软件解释技术，在现有操作系统上模拟指令集，从而在一个系统上运行另一个系统。运行性能低，当功能没问题。</p>
<p>仿真：通过现有机器的微程序，去实现另一个机器的指令集。性能高，当难度更高，更底层，有时候做不了。</p>
<p>模拟和仿真的区别： <br>
模拟用的机器语言程序解释实现，解释程序存储在主存中。</p>
<p>仿真通过微程序解释实现，解释程序存储在控制存储器中。</p>
<p>微程序机器 依赖于 传统机器语言机器级 ，所以两台计算机系统结构差异大时，很难仿真。仿真可以提高性能。</p>
<p>通常是仿真和模拟一起使用。</p>
<ol>
<li>不同软件系列移植一般用模拟和仿真并行。</li>
<li>经常使用，系统结构差异不大的 一般用仿真。</li>
<li>不经常使用，I/O等难以模拟的，一般用模拟。</li>
<li>两台机器差别不大也需要仿真和模拟同时使用，来完成机器间的映像。</li>
</ol>
<p>二 采用系列机<br>
通常系列机系统结构差别不大，易于移植，当也不是绝对可以。</p>
<p>发布系列机更新时，一般只能增加，不能删除，也不太能更改之前提供的更新内容。</p>
<p>三 统一高级语言<br>
统一高级语言软件移植技术应用于系统结构相同以至完全不同的的机器之间高级语言程序的软件移植。</p>
<p>是种理想的移植方式。</p>
<p>但是不太容易实现。</p>
<ol>
<li>程序员之间开发习惯不同。</li>
<li>不用的语言，语法需求不同。</li>
<li>语言的一些字段，存在争议。</li>
<li>不同厂家发展自己特色，再编译程序嵌入汇编语言，导致即使相同高级语言，编译程序都不相同。很难适配。</li>
</ol>
<h3 id="2-应用的发展对系统结构的影响">2. 应用的发展对系统结构的影响</h3>
<p>应用是系统结构发展的第一动力。<br>
多媒体，网络应用 的不断需求，促进个人PC不断更新换代。特别是大型游戏。</p>
<h3 id="3-器件的发展对系统结构的影响">3. 器件的发展对系统结构的影响</h3>
<p>1）非用户片，现场片，用户片 的概念。</p>
<ol>
<li>
<p>非用户片是在厂家制作后发售，用户只能使用，不能进行任何更改。又称通用片。</p>
</li>
<li>
<p>现场片是厂家发售后，用户可根据需求进行更改，使用灵活，功能强。（BIOS就在prom可编程只读存储器中）</p>
</li>
<li>
<p>用户片是经过定制而做的。销量低，成本高设计费用高，设计周期长。 如果完全按照用户要求定做 称为全用户片。</p>
</li>
</ol>
<hr>
<p>2）器件的发展是推送系统结构和组成的动力。</p>
<p>电子管-晶体管-小规模集成电路-大规模集成电路-超大规模集成电路。</p>
<p>非用户片-现场片-用户片</p>
<p>3）器件发展改变了设计逻辑</p>
<p>曾经是想着各种简化设计。</p>
<p>现在设计最主要是看应用。   （微汇编，微高级语言，计算机辅助设计软件的方法来设计）</p>
<p><strong>对用户片计算机，机器设计 和 芯片设计 密不可分。最主要是芯片设计。</strong></p>
<p>为了芯片的利用率，必须采用计算机辅助设计，通过计算机辅助系统。</p>
<h2 id="六-系统结构的并行性">六 系统结构的并行性</h2>
<h3 id="1-并行性">1. 并行性</h3>
<p>并行性的概念：在同一时刻或同一时间间隔，同时做出多个操作。</p>
<p>并行性有双重概念：</p>
<ol>
<li>同时性：同一时刻做出多个操作。</li>
<li>并发性：同一时间间隔做出多个操作。</li>
</ol>
<p>并行性目的：提高计算机处理性能。</p>
<p>并发和并行： <br>
并发 - 并发性<br>
并行 - 同时性</p>
<h3 id="2-并行性等级划分">2. 并行性等级划分</h3>
<ol>
<li>计算机系统执行程序的角度。   <br>
分为 指令内部 指令之间 任务和进程之间 作业和程序之间。</li>
</ol>
<ul>
<li>指令内部：一条指令的多个微操作并行性。</li>
<li>指令之间：指令和微操作都可以并行性。</li>
<li>任务或进程之间：多个任务或程序段并行性</li>
<li>作业或程序之间：多个计算机协同跑程序。</li>
</ul>
<ol start="2">
<li>计算机处理数据角度。</li>
</ol>
<ul>
<li>位串字串：每次只处理一个字（word），一个位（bit）。</li>
<li>位并字串：每次处理一个字（word）的多个位（bit）。</li>
<li>位片串字并：每次处理多个字（word），每个字处理一个位（bit）</li>
<li>全并行：字并行处理，字的位也并行处理。</li>
</ul>
<ol start="3">
<li>计算机信息加工的各个步骤和阶段的角度</li>
</ol>
<ul>
<li>存储器操作并行：存储器用各种访问方式，对要操作的内容，进行并行的 比较 检索 更新 变换等操作。 典型例子是 并行储存系统 和 以相联储存器微核心构成的 相联处理机。</li>
<li>处理器操作步骤并行：指令的，取指，分析，执行等操作，执行步骤在流水线上处理。 典型例子是 流水线处理机。</li>
<li>处理器操作并行：多个处理机，在一个控制器下，对指令的多个微操作（步骤）进行并行性的处理。</li>
<li>指令 任务 作业 并行：多个处理机，对多个指令并行性处理，也对每个指令的步骤，并行性处理。</li>
</ul>
<h3 id="3-沿3种并行性开发途径的多机系列类型和特点">3. 沿3种并行性开发途径的多机系列类型和特点</h3>
<ol>
<li>时间重叠：在同一个硬件条件下，通过流水线的方式处理，以提升处理效率。</li>
<li>资源重复：推硬件，以提高性能。</li>
<li>资源共享：用软件实现，使多个任务按一定顺序，轮流使用同一套硬件设备。 多道程序分时系统 就是典型的资源共享案列。</li>
</ol>
<h3 id="4-耦合度">4. 耦合度</h3>
<p>耦合度分为，最低耦合，松散耦合，紧密耦合。耦合度可以看为物理硬件紧密程度，交叉作用能力的强弱。</p>
<ol>
<li>
<p>最低耦合：各脱机处理机就是最低耦合，各机器之间，除了存储硬件，没有任何物理连接，或共享联机硬件。</p>
</li>
<li>
<p>松散耦合：如果多台计算机通过通道，或网络通信通道实现互联，共享外围设备。从最低频带在文件或数据集相互作用。则称之为松散耦合系统或间接耦合系统。</p>
</li>
<li>
<p>紧密耦合：如果多台计算机通过总线或高速开关互联，有较高的信息传播率，可实现数据集，任务级，作业级 并行。则称之为 紧密耦合系统 或直接耦合系统。</p>
</li>
</ol>
<h3 id="5-flynn分类法">5. Flynn分类法</h3>
<p>按照指令流和数据流，处理时的多倍性进行分类。<br>
分为</p>
<p>单指令流单数据流（SISD）<br>
单指令流多数据流（SIMD）<br>
多指令流单数据流（MISD）（无实际对照）<br>
多指令流多数据流（MIMD）</p>

    
    <div class="nav-next-prev">
        <div class="nav-prev">
            
                <a href="https://itscola.github.io/blog/9.computersystemframework-1.5-2/"><i class="fas fa-chevron-left"></i></a>
            
        </div>
        <a class="nav-top" href="#">top</i></a>
        <div class="nav-next">
            
                <a href="https://itscola.github.io/blog/11.computersystemframework-2.1-1/"><i class="fas fa-chevron-right"></i></a>
            
        </div>
    </div>
    

            </div><footer>
<div class="footer-content">

  <div class="contact-info">
      
          <div class="footer-mail">
          <i class="far fa-envelope"></i> <a href="">QQ: 1302399643</a> </div>
      
      
  </div>


<p class="copyright meta">志存高远 , 以梦为马.</p>

</div>
</footer></main>
    </body>
    <script src=https://itscola.github.io/js/navbutton.js></script>
</html>
