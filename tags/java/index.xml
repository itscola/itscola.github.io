<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on White_cola Blog</title>
    <link>https://itscola.github.io/tags/java/</link>
    <description>Recent content in Java on White_cola Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>失落和喜悦不断交缠，执着的一切充满挑战。
 Blog Powered by Hugo.</copyright>
    <lastBuildDate>Tue, 25 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://itscola.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HiPlugin Bukkit开发框架 命令系统 (一)</title>
      <link>https://itscola.github.io/blog/bukkit/hiplugin-hicommand-01/</link>
      <pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/bukkit/hiplugin-hicommand-01/</guid>
      <description>在看这篇文章之前, 确保你已经有java开发, Bukkit插件开发的基础.
一, 什么是HiPlugin Bukkit 插件开发中, 很多地方都较为麻烦. 比如 处理指令的tab. 或者 通过代码创建各种物品(需要不停转换).
调用 NMS(net.minecraft.server)时, 如获取物品的NBT 并保存, 需要各种Java反射. 而要实现一些高端的功能, 又经常用到NMS .
不仅如此 对于部分新人 一不小心, 项目的代码质量就会大幅下降, 到后期很难维护.
 代码质量主要体现在开发者写的代码的水平, 它是面向开发者的, 通常代码水平越差, 项目后期越难维护, 代码可读性越差. 代码质量与成品 有没有bug , 稳不稳定, 好不好用 没有直接关系.
 为了实现更简单的开发, 并保持较高的代码质量 , HiPlugin出现了.
它是面向插件开发者的插件开发框架.
 自动处理命令与tab, 直接操纵NBT, 直接序列化物品再反序列化 , 创建物品一步到位&amp;hellip;.
它有以下与众不同的特点:
  易用, 倾向于面向对象, 保持较高的代码质量下, 非常易学. 即使是Bukkit新手 , 也能几分钟内, 就能完全掌握框架的一两个功能.
  高质量代码. 使用HiPlugin处理繁杂功能, 进行自动化管理. 插件开发者只需要把要处理的内容交给HiPlugin即可.
  创新. 打破思维局限性.</description>
    </item>
    
    <item>
      <title>什么是编译器,解释器? (一文理解编译型和解释型语言)</title>
      <link>https://itscola.github.io/blog/compiler-and-interpreter/</link>
      <pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/compiler-and-interpreter/</guid>
      <description>编程语言  我们所用的程序都是用某种语言写的, 但是它会先被翻译成能被计算机执行的语言之后才能运行. 通常人们会通过它用了 编译器(compiler) 还是 解释器(interpreter) 来判定他解释型还是编译型语言. 如java这种又用了 编译器 又用了 解释器 通常被我们称为 半解释半编译型语言.  编译器和解释器 编译器 编译器就是一个程序.它会把我们的 源代码写的程序 翻译成 一种等价的 另一种语言 写的程序.
在它进行翻译的过程中, 还会报告它在源代码中发现的错误.
 源代码写的程序 -编译器-&amp;gt; 目标程序
目标程序就可以处理 用户的输入 得到对应的 输出  解释器 解释器不会进行翻译来生成目标程序, 而是直接通过 用户的输入 和 源程序 来生成目标程序.
 源代码写的程序 + 用户的输入 -解释器-&amp;gt; 目标程序  优缺点  通过编译器生成的目标程序 来处理用户的输入 通常比用一个解释器快很多. 通过解释器来运行 由于它是逐个语句来执行 错误诊断效果通常比编译器好.  Java的半编译半解释 Java就是个半编译半解释形语言 java源程序会被编译成字节码(bytecode)(中间代码),然后再由JVM(java虚拟机) 解释执行. 也通过中间代码 实现了跨平台.
补充 在编译器和解释器前后, 还会有一些其他步骤. 这边主要聊编译器和解释器.</description>
    </item>
    
    <item>
      <title>Gradle快速掌握基础用法</title>
      <link>https://itscola.github.io/blog/gradle-basic/</link>
      <pubDate>Wed, 24 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/gradle-basic/</guid>
      <description>Why Gradle？  Gradle是一款自动化构建项目的开源工具。 它使用Groovy来声明项目设置。和maven相比，它抛弃了繁杂的xml配置，同时配置文件做到简洁美观。 很多开源项目 需要使用gradle构建。 Java应用为主 目前支持 Java、Groovy、Kotlin和Scala.  下载并配置 下载地址： 点击下载 这里下载all版本，包含了源码、文档、示例等内容。
配置环境变量：  将压缩包解压到任意目录. 打开环境变量配置，添加系统变量到这个目录，命名为Gradle_Home。 选择用户变量中的path，添加%Gradle_Home%/bin 。 在cmd中输入 gradle -v 如果出现显示的gradle版本，代表配置成功。  使用本地maven仓库 如果每个项目都要从maven仓库下载一次依赖, 那么将会占用很多空间, 并影响开发效率. 我们可以通过配置环境变量, 先让gradle找本地下载过的依赖, 如果没有 那再去maven仓库下载.
首先选择一个本地的maven仓库文件夹路径. 然后打开环境变量配置, 在系统变量新建一个变量 变量名为 GRADLE_USER_HOME 变量值为上一步选择的本地 maven仓库文件夹.
今后gradle会先从本地maven仓库找jar包 , 找不到再去maven仓库下载到本地maven仓库.
IDEA创建gradle项目与配置 在Idea中创建Gradle项目 配置build.gradle  主要配置内容:
   repositories主要是选定的maven仓库 默认为maven中央仓库
当然你也可以添加仓库 可以参考 阿里的Maven仓库镜像 的教程来设定  在denpdencies添加jar坐标(依赖):   从你所添加的maven仓库添加:
这里用默认的 maven中央仓库. 首先打开你所要添加的仓库页面, 搜索你要添加的jar. 点击search. 找到后点击.</description>
    </item>
    
  </channel>
</rss>
