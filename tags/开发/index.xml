<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发 on White_cola Blog</title>
    <link>https://itscola.github.io/tags/%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 开发 on White_cola Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>失落和喜悦不断交缠，执着的一切充满挑战。
 Blog Powered by Hugo.</copyright>
    <lastBuildDate>Thu, 20 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://itscola.github.io/tags/%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>(数据表示,)寻址方式(与指令系统) 2.2.2-2</title>
      <link>https://itscola.github.io/blog/14.computersystemframework-2.2.2-2/</link>
      <pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/14.computersystemframework-2.2.2-2/</guid>
      <description>提示：本篇涉及少量 编程，汇编 相关内容，不会可能看不懂。
一，逻辑空间 和 主存空间 1. 逻辑地址与主存物理地址的概念 形式地址和实际地址是针对的所有的寻址，而逻辑地址与主存物理地址针对的是主存。
 逻辑地址：开发者编程用到的地址。
物理地址：程序在主存中实际的地址
 当定义一个字段(变量)，会开辟内存空间，给字段使用。从0号地址 向后分配(0,1,2,3,4&amp;hellip;)。
这样就有一个问题，如果我同时运行多个程序，每个程序都有字段占用0号地址 然后向后分配到内存空间。不可能每个都将一个内存空间 从0开始向后占用。
所以我们就定义出 逻辑地址 和 主存物理地址。
我们给每个程序定义一个虚拟空间，称为“逻辑空间”，每个空间都占用逻辑地址都从0开始向后。
逻辑空间是在磁盘上的，因此，逻辑空间 可以大于 物理空间，也可以小于 物理空间。
物理地址则是程序在物理空间中的实际位置。
可以理解为，我们通过磁盘，给每个程序虚拟出一个逻辑空间，然后让程序在逻辑空间中存储。在程序运行时，我们再把逻辑空间的数据 放到物理空间。以便程序所占空间的位置，不会互相影响。
逻辑地址都是虚拟的，你把握不住，程子。
2. 逻辑地址与主存物理地址的分配 虽然程序在 逻辑空间 里，但实际运行时，还是要在 物理空间 中运行，才能真正工作。
主存 会在 物理空间 找一个空位，把磁盘中 逻辑空间内的数据，放到 主存中物理空间的 空位中。
假如逻辑空间中，逻辑地址是，0，a , b , c , d . 主存中正好第 x位开始有空余空间。 那么我们把这些数据放到主存这个位置中，主存物理地址 就成了 0 + x , a + x , c + x , d+x &amp;hellip;.</description>
    </item>
    
    <item>
      <title>Unity基础操作与窗口布局 学习日记01</title>
      <link>https://itscola.github.io/blog/unity2d/what-is-sprite-in-unity/</link>
      <pubDate>Wed, 19 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/unity2d/what-is-sprite-in-unity/</guid>
      <description>Unity Engine for 2D Games 01 欢迎来到我的Unity学习日记, 是时候做个属于自己的游戏了.
我将会在这个系列中记录我学到的Unity知识.
Unity是一个很有名的游戏制作引擎, 如果你需要介绍, 可以上网搜索.
很多不错的游戏由Unity开发 , 举个最近游戏的例子 , 原神.
Unity并不是只能开发画质不高 或 小型 游戏, 它同样可以做到UE引擎能做到的画质. 这是刻板印象了.
Unity好上手 , 就导致经常看到Unity的小游戏出现.
在Unity中创建Sprites(精灵) / 并了解基本操作 1. 何为Sprites (精灵) 精灵 是从 &amp;ldquo;像素图片&amp;rdquo; 中, 得到的 2D 对象.
我们可以让它走路. 让它攻击 , 让它跳跃 , 再或者 , 我们可以让它飞起来.
它可以是一个2D游戏中的 NPC 也可以是一个怪物 , 更可以是一个主角.
图片来自 https://www.pixiv.net/artworks/89921205
2. Unity窗口布局 - 创建一个精灵 首先,我们创建一个2D Unity项目,然后将Unity切换为默认布局. Unity有
 Hierarchy (层级窗口) Game 视图 (游戏窗口) Scene 视图 (场景窗口) Inspector 窗口 Project 窗口 (项目窗口)   这些窗口将会在动手操作时 , 让你搞懂.</description>
    </item>
    
    <item>
      <title>(数据表示,)寻址方式(与指令系统) 2.2-1</title>
      <link>https://itscola.github.io/blog/13.computersystemframework-2.2-1/</link>
      <pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/13.computersystemframework-2.2-1/</guid>
      <description>提示：本篇文章涉及少量汇编内容。
1. 寻址方式(addressing mode)的定义⭐️ 寻址方式指的是 指令通过什么方式来 寻找/访问 需要的数据(操作数或信息)的地址。
不同的计算机系统都有不同的寻址方式。
也就是说，执行一条指令， 这条指令需要通过什么方式来访问数据的 地址。
地址在指令中主要有两种：
1. 形式地址：通常需要给指令的每一个操作数加一个地址。 先要知道一条指令由 操作码 和 操作数 构成。
 操作数指出了指令执行的操作所需要数据的来源。
 图中操作数的位置/字段 可以是操作数本身。
也可以是 要指向操作数 的操作地址，也可以是 要指向操作数 的操作地址 的计算方法。也就是地址码。
而操作码 就表示我们要进行的操作。 比如ADD ，MOV &amp;hellip;&amp;hellip;.
一条汇编指令：MOV(操作码) 操作数字段(操作数 操作数) 如 MOV AH，06H 每个指令里都可能包含多个地址，也可能不含有地址。但如果指令里给出了地址，那么我们称 指令中给出的地址为 形式地址。
如 ADD A1 , A2 这里的A1和A2都是形式地址。
2. 实际地址：使用形式地址信息按照一定规则计算出来的 数值/数据 称为实际地址 通常我们指令中给出的形式地址，需要按照规则进行一定的计算然后才能得出真正的 数值/数据 ， 我们把这通过计算后的 真正的 数值/数据 称为 实际地址。
实际地址才能访问 寄存器 或 主存 的数据。
如 ADD A1 , A2 + MEM[1200] ， 操作数字段的第二个操作数(A2 + MEM[1200]) 需要先进行计算, 然后形成的实际访问 寄存器 或 主存 中 真正数据的地址 就是实际地址。之后，赋值给A1时，再形成实际地址。</description>
    </item>
    
    <item>
      <title>Bootstrap前端开发框架-栅格系统-2</title>
      <link>https://itscola.github.io/blog/browserside/2.bootstrap/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/browserside/2.bootstrap/</guid>
      <description>Bootstrap-栅格系统-2 在读这篇文章前, 如果你不了解 栅格系统 的概念, 点击此处去上一篇
欢迎来到前端教程的bootstrap系列，
 Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。
 开发一个网站，非常简单，也许只需要1天html，css，js的学习，就能学会。
但是如果要开发一个完善的网站，那就需要花点力气了。
要学习前端，bootstrap是一个必学的内容。
栅格系统的文章将 教你 如何实现网页面根据屏幕尺寸自动变化(页面响应式)。
我们的Bootstrap系列为了读者的学习效率，将不对框架作使用之外的介绍。那些介绍你可以通过搜索引擎搜索来获得相关信息。在阅读这个系列之前，确保你已经有html，css，js基础。
 栅格系统我们将分为两篇文章来讲，第一篇为概念与原理的讲解，第二篇是实际写代码操作的讲解。
  栅格系统为Bootstrap的第一章，我们之所以不和其它教程一样先讲Bootstrap中其它的，是因为这个比起其它内容更重要，也更核心。 注意，我们这是“教程”，不是“文档”。
 一. Bootstrap的安装 注意,如果你要使用bootstrap.js 还需要JQ作为库. 这里仅演示了Bootstrap.css中的栅格系统.

1. 下载 我们可以在 Bootstrap中文文档 的网站进行安装.
首先我们将看到,这边有用于 生产环境的Bootstrap 和 Bootstrap源码.
生产环境的是经过压缩的, 为了加载更快, 而我们要学习它,那么选择源码. 点击下载源码. 下载好后解压,并找到dist文件夹,然后再找到js文件夹. Bootstrap.js 为没有压缩过的,占用相比大些.
Bootstrap.min.js 为压缩过的, 占用相比较小.
2. 引入到项目 首先将dist文件夹内的所有文件夹(包括内容), 复制进项目中. 在项目的html代码中, 引入Bootstrap的css文件 与 js文件.
二. 栅格系统的使用 1. 定义容器 2. 定义行 3.</description>
    </item>
    
    <item>
      <title>Bootstrap前端开发框架-栅格系统-1</title>
      <link>https://itscola.github.io/blog/browserside/1.bootstrap/</link>
      <pubDate>Sun, 16 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/browserside/1.bootstrap/</guid>
      <description>Bootstrap-栅格系统-1 欢迎来到前端教程的bootstrap系列，
 Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。
 开发一个网站，非常简单，也许只需要1天html，css，js的学习，就能学会。
但是如果要开发一个完善的网站，那就需要花点力气了。
要学习前端，bootstrap是一个必学的内容。
栅格系统的文章将 教你 如何实现网页面根据屏幕尺寸自动变化(页面响应式)。
我们的Bootstrap系列为了读者的学习效率，将不对框架作使用之外的介绍。那些介绍你可以通过搜索引擎搜索来获得相关信息。在阅读这个系列之前，确保你已经有html，css，js基础。
 栅格系统我们将分为两篇文章来讲，第一篇为概念与原理的讲解，第二篇是实际写代码操作的讲解。
  栅格系统为Bootstrap的第一章，我们之所以不和其它教程一样先讲Bootstrap中其它的，是因为这个比起其它内容更重要，也更核心。 注意，我们这是“教程”，不是“文档”。
 一.响应式 1. 响应式 网站响应式 指的是一个网站下，无论我们用什么大小的屏幕/设备访问。网站都能通过自动变化布局，按我们的需求展现网页的内容。
2. 为什么要响应式 我们在电脑上开发好一个前端页面后，当我们用手机访问，它显示效果并不一定会好，因为布局的内容对于手机来说太小了，又或是布局变混乱了。
如果我们针对不同显示设备做不同的网站，那将会非常麻烦。
通过响应式布局，我们可以在同一个网站上，使用不同的设备，显示出针对不同设备的不同布局。
3. 响应式效果 比如 Bootstrap中文文档 这个网站。
手机访问是这样的：
电脑/ipad 访问是这样的：
这是同一个网站，只不过网站根据我们的显示面积进行了布局的调整。
布局不同，当显示的内容是一样的。
二. 栅格系统的概念 1. 什么是数栅格系统 栅格系统可以实现自动化的网站响应式，它通过将网站页面内容划分为“栅格”，然后对不同的尺寸的显示屏自动调整“栅格”，来做到。
也就是说，我们需要将我们网站的元素放到框架提供的“栅格”里，然后由“栅格系统”自动化调整”栅格布局“。
2. 栅格系统从哪来 “栅格系统” 来自各种前端框架，本期我们将学习Bootstrap的栅格系统。
三. 栅格系统做响应式的原理 1. 栅格 栅格系统会将我们的页面中定义的“行”，平均分成12个格，我们主要做的仅仅是将html元素装入对应的格。
html元素可以是一个div，可以是一堆 文字，又可以是一个图片&amp;hellip;&amp;hellip;
平均分的12个格是根据尺寸来分的。手机上分的12个格的空间明显要小于电脑端的12个格。
就比如，同一个元素，在PC端占用6格，而在手机端占用12格。这就是以 栅格系统 做响应式的基本原理。 通常会根据栅格系统自动调整.
不仅如此，就算是PC端，栅格系统 也会根据不同尺寸屏幕，自动调整 “栅格”以及其元素 的尺寸，</description>
    </item>
    
    <item>
      <title>数据表示,(寻址方式与指令系统) 2.2</title>
      <link>https://itscola.github.io/blog/12.computersystemframework-2.1-2/</link>
      <pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/12.computersystemframework-2.1-2/</guid>
      <description>数据表示,寻址方式与指令系统 2.1-2 要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列 （2.1-2）
这一篇为2.1的第二篇，接着上一篇来。
三 引入数据表示的原则 我们可以将数据变为可数据表示的类型，以便于提高对数据处理的速度，性能。也可以不那么做，这会以硬件复杂度等为代价。所以，我们需要一些原则来参考。什么样的最好引入，而什么样的不一定要引入。
1. 原则1 看引入数据以支持数据表示后，系统的效率是否有提高。
判断依据：实现时间 和 所需的存储空间是否有显著减少。
实现时间的是否减少，主要是看主存和处理机之间传送的信息量是否减少。 传送信息越少，实现时间越少。（取主存的数据，比起CPU慢很多。）
（数据类型被变成可以数据表示的数据，那么原本的数据类型消失 导致在主存和处理机之间传送的信息量必然减少。由于不需要算法封装数据表示实现数据类型，所占用的存储空间也必然减少）
2. 原则2 引入数据后，通用性和利用率是否提高。
也就是说，是否很多场合可以用 以及 有没有被高频率使用。
四 浮点数尾数基址大小和下溢出处理方法的选择。 新增加一个数据表示后，我们需要考虑的问题。 如：怎么来表达？
这里用浮点数的尾数来举例。（如1.1111111该怎么用硬件表达。用不同方式的影响。）
下溢处理：数据在进行加减乘除等计算时，会不可避免的遇到溢出问题。这里要研究如何处理这些问题。上溢（超出范围），下溢（超出最小值范围）。
1. 浮点尾数基址大小 首先来看浮点数的一般格式。
 阶码部分可以用原码，补码或增码（也称移码）表示，不管怎么样表示，p+1位阶码部分中影响阶值大小的实际只有p位。
 阶段码部分通常使用二进制，给尾数部分留出空间。 这里主要看尾数的设计。
尾数二进制设计： Rm = 2.
尾数八进制设计: Rm = 8.
尾数十进制设计： Rm = 10 .
尾数十六进制: Rm = 16
Rm在这边代表了进制。
本篇文章未完待续 目前这里展示没更新完，之后会补上。（需要更好多方式向读者来解释清楚这边） 我会发布一个单独的文章来讲解这边,之后在这篇文章引用.</description>
    </item>
    
    <item>
      <title>数据表示,寻址方式与指令系统 2.1-1[N]</title>
      <link>https://itscola.github.io/blog/11.computersystemframework-2.1-1/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/11.computersystemframework-2.1-1/</guid>
      <description>数据表示,寻址方式与指令系统 2.1-1 要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列 （2.1-1）
2021-5-8 - 此篇文章进行了一次更新。
一 数据表示与数据结构 1. 数据表示 数据表示：指的是计算机硬件能识别和引用的数据类型。表现在它有对这种类型的数据进行操作的指令和运算部件。数据表示的实质是软硬件的取舍。
也就是说，数据表示指的是，计算机能够用硬件表示（识别、引用）数据类型，的表示方法。
（通常是什么int，double，char 最常用，相比简单，硬件实现容易的几种）
2. 数据结构 数据结构是要 通过软件映像，变换成计算机中所有具有的数据表示来实现。
举个例子，我们要是找份工作，比如java工程师。然后面试官问 “你对数据结构的理解怎么样？” 那我们知道，问的就是HashMap，ArrayList，Vector，String，Integer等具体怎么实现的。没错，这些就是数据结构。
比如我们反编译Integer，会发现它就是用简单的算法和int 实现的。
树，向量，链表，集合，都是数据结构。
也就是说，我们把能数据表示的数据，通过软件方式（算法）封装，封装成了一种软件实现的新的数据类型，为“数据结构”。虽然是软件方式（算法封装）实现的数据结构，但到计算机执行时，还是用的计算机硬件能表示的数据类型（数据表示）。
 数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素的集合。
 那么，我们能用int实现Integer，用char[]实现String。所以说
不同的数据表示，能为数据结构提供不同的支持，表现在实现效率和方便性不同。
建议动手反编译一个ArrayList试试，能看到是如何用 数据表示的数据类型+算法 实现的。常见的java反编译器有jd-gui , luyten &amp;hellip;.
3. 数据表示与数据结构 开发中，我们把软件封装实现的数据结构作为一种类型使用，它的下一层是计算机硬件表示的数据。
因此，数据结构和数据表示是软硬件的交界面。
研究：我们在 数据表示的数据 和 数据结构 分配时，要根据需求，以适当的硬件花费为代价，考虑设计哪些 数据表示 ， 以对 数据结构 带来高效率，方便性的支持。
因此，数据表示的确定实质上上软硬件的取舍。
就比如我们计算机中经常用字符串，那么我们就可以用硬件实现一个（变为 “数据表示”的），原来先用字符封装而成的，而现在可用硬件 表示（识别和引用），那么我软件上得到了硬件支持，效率就会大大增加。这就是一个简单的研究过程演示。
4. 数据表示类型(例子)   当机器设置有定点加，减，乘，除，位移，比较等定点运算指令和相应的运算硬件，可以直接对定点数进行各种处理时，计算机就有了定点数据表示。    当机器设置有了逻辑加，逻辑乘，按位相加，逻辑位移等逻辑运算指令和相应的逻辑运算硬件，可以直接对逻辑数进行各种处理时，计算机就有了逻辑数据表示。    当机器有了浮点运算指令，（浮点加，减，乘除，比较，存）和相应的运算硬件，可以进行直接对浮点数进行各种处理时，计算机就有了浮点数据表示。   只有定点数据时。逻辑数据和浮点数据可以通过 定点数据 靠算法封装实现。但能进行逻辑数据表示 和 浮点数据表示 后，有计算机硬件的支持，效率和方便程度都会大大提升。</description>
    </item>
    
    <item>
      <title>计算机系统结构总结(一)</title>
      <link>https://itscola.github.io/blog/10.computersystemframeworksummary1/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/10.computersystemframeworksummary1/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
欢迎来到这个系列的第一章的最后一篇文章，这一篇，将总结从1.1-1.5-2的所有内容。
这篇文章是之前的总结，不会进行任何概念上的讲解。
这篇文章是之前的总结，不会进行任何概念上的讲解。
这篇文章是之前的总结，不会进行任何概念上的讲解。
一 计算机系统层次结构 计算机系统分了几层，每一层我们称之为“机器级”。
1. 机器级的概念 计算机系统按照从高级到低级，分成6层，分别为 应用语言机器级、高级语言机器级、汇编语言机器级、操作系统机器级、传统机器语言机器级、微程序机器级。
2. 分级意义 在分级的情况下，任意一级的下级机器级，我们都是不太用关注的，但确实客观存在的。
机器级可以简化系统逻辑，但也会带来不可控制的问题。
3. 机器级的实现 机器级通过 翻译 或 解释 再或是两种豆使用，来实现机器级之间的交互。
翻译：先用转换程序，将上一级机器级的程序翻译为下一级机器级上的等价的程序，然后在下一级机器级继续实现。
解释：用低一级的机器级上的一串语句或指令来仿真高级机器级上的一条语句或指令功能。
特点：
翻译技术是先翻译然后执行。 效率较高。 解释技术是一边解释一遍运行。更灵活，当效率较低。
4.机器级的特点  应用语言程序，通过程序包翻译成高级语言程序。 高级语言程序通过编译程序，翻译成汇编语言程序。 汇编语言程序通过汇编器，翻译成机器语言程序。 操作系统通过机器语言程序解释控制语句作业。 传统语言机器级（固件），通过微指令程序解释指令。 微程序机器级（硬件）通过微指令系统直接执行微指令。  二 计算机系统结构的概念 1. 透明度 概念：一些客观存在的事物或属性，在某一角度看不到，那么我们说这些事物或属性对于这一角度是透明的。
作用：
 简化所在机器级的设计。（好处） 带来无法控制的问题。（坏处）  2. 系统结构 概念：系统结构是对各机器级上的界面的定义，和上下级功能分配。
研究：系统结构研究各机器级上，哪些是透明的，哪些是不透明的。
3. 计算机系统结构 概念：计算机系统结构又称计算机体系结构，是系统结构的一部分。指的就是 传统机器语言机器级 的结构。
在它之上是 操作系统机器级 汇编语言机器级 高级语言机器级 应用语言机器级，在它之下是固件和硬件，所以它是软件和硬件的交界面。
是汇编语言程序设计或编译语言程序设计者所看到的抽象概念。</description>
    </item>
    
    <item>
      <title>系统结构中的并行性开发及计算机系统的分类1.5-2</title>
      <link>https://itscola.github.io/blog/9.computersystemframework-1.5-2/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/9.computersystemframework-1.5-2/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
并行性 在读本篇文章前，确保你已经读过了
系统结构中的并行性开发及计算机系统的分类1.5-1
一 沿3种并行性开发途径的多机系统类型和特点 提高并行性的常用技术途径有三种。
时间重叠，资源重复，资源共享。
1. 时间重叠（流水线） 引入时间因素，让多个处理过程在时间上相互绰开，轮流重叠地使用同一套硬件设备的各个部分，加快硬件周转来赢得速度。
其实就是一种流水线运行方式。下面来解释一下，假如你看不懂上面的，很正常。还没解释。
比如要运行
-&amp;gt; 取指 -&amp;gt; 分析 -&amp;gt; 执行
那么在流水线中将这样运行。
每条指令的各个步骤，轮流在相应硬件上执行。5个Δt（指令周期） 就可以解析完3条指令。大大加快了程序的执行速度，时间重叠基本上不必重复增加硬件设备就可以较大地提高计算机系统的性能价格比。
2. 资源重复 引入空间因素，通过重复设置硬件资源来提高可靠性或性能。
简单来说，就是堆硬件。性能不够，硬件来凑。
通过设置N个完全相同的处理单元（PE），在同一控制器（CU）的控制下，给各处理单元分配不同的数据，完成指令要求的同一种运算或操作，一提高速度性能。
体现了同时性。
资源重复不仅可提高 可靠性 还可以提高系统的 速度性能。
3. 资源共享 用软件实现，使多个任务（进程 、线程&amp;hellip;）按一定时间顺序轮流使用同一套硬件设备。
多道程序分时系统就是典型的资源共享实例。
资源共享不仅只是CPU、主存、外设等硬件资源共享，也可以包括软件、信息资源的共享。
4. 补充 在实际并行性使用上，这三种方式是同时使用的。
二 耦合度 写代码的时候，我们经常通过各种设计模式降低耦合度（解耦）。各大公司里，也会尽量降低员工的耦合度（解耦）。
拿公司举例，耦合度低，可以就是 一个员工不干了，换一个员工就能接着他的工作干。无法造成什么影响。 反之，耦合度高了，一个员工不干了，会影响到整个团队。这对于公司是不利的。（一般越大的公司，耦合度越低）
拿程序举例，我现在用的Oracle的付费数据库，突然有一天，我发现不太划算，于是我换了MySQL数据库。 通过接口（Implement）或什么 IOC（控制反转）等 ，说换就换，造成不了什么影响。 那么说明耦合度不高。
反之，我换了MySQl，整个系统就要瘫痪了，那么说明耦合度较高。
所以你可以把它理解为，整体对整体中的单个的依赖程度。 依赖程度高，耦合度就高。依赖程度低，耦合度就低。
通常我们都更希望耦合度低一点，当也不是绝对的。
 好，理解了耦合度，那么我们现在要把耦合度的概念代入计算机系统结构了。
 一般用耦合度系统反应各机器之间物理连接的紧密度，和交叉作用能力的强弱，有最低耦合度，松散耦合，紧密耦合 之分。
 那么很明显，计算机系统结构的耦合度指的是 机器物理连接紧密度（硬件耦合度） 和 交叉作用能力强弱（交叉工作耦合度）。 还分为三级，最低耦合度，松散耦合，紧密耦合。</description>
    </item>
    
    <item>
      <title>系统结构中的并行性开发及计算机系统的分类1.5-1</title>
      <link>https://itscola.github.io/blog/8.computersystemframework-1.5-1/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/8.computersystemframework-1.5-1/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
一 并行性 现代以及未来的计算机，都是并行的。并行能大大提高计算效率。
1. 并行性的定义 计算机在 同一时刻 或 同一时间间隔，进行运算或操作的特性，称为并行性。
按照 同一时刻 或 同一时间间隔 可将 并行性 分类两类（两重含义）
同时性 和 并发性。
1.1 同时性 定义：一个以上的事件 同一时刻 发生。
如CPU的两个核，分别同时运行两个程序，这就是同时发生的。
1.2 并发性 定义：一个以上的事件 同一时间间隔 发生。
如很多游戏，多个人在一起PVP（Player vs player），实际上是 一个人动一下 之后下一个人动一下 再 下一个人动一下&amp;hellip;.. 这就是并行性。
由于切换非常快，所以就看上去是同时在动。
2. 并行性目的 并行性的目的是为了能并行处理，以提高计算机解题效率。
并发和并行（补充） 和性质命名不太一样。我们说的“并行”“并发”是两种方式 ，是有区别的。
并行 对应的 同时性。
并发 对应的是 并发性。
不要把 性质 和 方式 搞混。
二 并行性等级划分 并行性可以以多种角度进行多种划分。
1. 计算机系统执行程序的角度 从计算机系统执行程序的角度来看，并行性等级由低到高可分为四级。</description>
    </item>
    
    <item>
      <title>[1.4]应用 器件 的发展对系统结构的影响1.4-2</title>
      <link>https://itscola.github.io/blog/7.computersystemframework-1.4-2/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/7.computersystemframework-1.4-2/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
应用发展对计算机系统的影响 应用的需求时计算机发展的最大动力。
（没有应用需求，很难有动力）
由于需求，计算机系统结构才不断地提高性能。
需求：
多媒体：大型游戏，高清视频 网络应用：云计算，防火墙，高性能路由器 科学计算：机器学习，天气预报
其中大型游戏是促进个人电脑更新换代的最大动力。
器件发展对系统结构的影响 1. 非用户片，现场片，用户片 的定义。 非用户片：
也称“通用片”，其功能是由器件厂家生产时固定的，器件的用户只能使用，不能更改器件的内部功能。
现场片：
用户可根据需求更改器件内部功能。在20世纪70年代中期出现。使用灵活，功能强，可取代硬联组合网络，还可以构成时序网络。
如：可编程只读储存器PROM（BIOS所用）、现场可编程逻辑阵列FPLA等。
用户片：
专门按照用户要求，生成高集成度VLSI器件。 设计周期长，设计费用高，销量小，成本高。
（如果是完全按照需求设计的用户片，称为全用户片。）
苹果公司直呼内行
2. 器件发展是推动系统结构和组成前进的因素 电子管 -&amp;gt; 晶体管 -&amp;gt; 小规模集成电路 -&amp;gt; 大规模集成电路 -&amp;gt; 超大规模集成电路
非用户片 -&amp;gt; 现场片 -&amp;gt; 用户片
制造工艺也在进步。
国外的光刻机是好几个国家联合研发的。但它们不愿意卖给我们国家。我们必须研发自己的光刻机。这对我们国家的未来真的十分重要。尽管非常非常艰难。
工艺越强大 ：集成度上升 功耗下降 主频上升 性能上升。
3. 器件发展改变了逻辑设计的方法 过去的设计逻辑：专注逻辑简化 和 各种节省。（节省功耗、降低成本、提高速度） （对现在的VLSI不适应）
VLSI是超大规模集成电路(Very Large Scale Integration)的简称
目前的设计逻辑：
最主要是应用。（微汇编，微高级语言，计算机辅助设计软件的方法来设计）
对于用户片的计算机 ，机器设计 和 芯片设计 密不可分，机器设计的关键是芯片设计。</description>
    </item>
    
    <item>
      <title>[1.4]软件的发展对系统结构的影响1.4-1</title>
      <link>https://itscola.github.io/blog/6.computersystemframework-1.4-1/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/6.computersystemframework-1.4-1/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
软件的发展对系统结构的影响 软件发展对系统结构的影响，主要体现在可移植性方面。
1. 软件的可以移植性 可移植性的概念：一款程序不经修改，或只需要少量的修改，就可以由一台计算机移植到另一台计算机。同一软件应用于不同环境。
一台计算机移植到另一台计算机，不经修改，或修改的很少，我们就说 可移植性 越好。反之 越差。
每次发布新硬件，都要考虑可移植性，可移植性越高越好。
假如我发布了一个显卡，性能比市面上显卡性能普遍较高，但是显卡的 可移植性很差，不兼容市面上所有程序。也就是说程序完全需要从0设计。 通常是不会有生命力的。
2. 可移植性特点  软件能长期使用，不会因为机器更新需要重新编写。 大大减少了编程软件的工作量。 能迅速用上新的硬件技术，更新系统，让新系统立即发挥效能。 软件设计者将更有精力开发全新的软件。  实现可移植性的几种方法 实现可移植性主要有三种方法。
1. 统一高级语言 统一高级语言，是一种理想的软件移植方法。
让所有程序员使用统一的高级语言，这样只需要各个操作系统对这种语言适配（操作系统的全部或一部分使用这种语言），即可实现软件的高可移植性。
但直到如今，没有一种是对各种应用真正通用的高级语言。
又很多语言去尝试，比如跨平台比较优秀的 haxe语言，它可以编译成Java，CPP，JavaScript，C#，JVM，PHP，Python&amp;hellip;&amp;hellip; 。以及几乎支持所有常见平台。实现真正跨平台。但目前还是小众语言，原因也如下列所说。 Haxe - Github
原因如下：
（如果理解加粗字体，就可以不用看后面的内容）
  不同用途要求语言语法不同，如Julia语言面向科学计算，Java面向程序开发。它们的语义语法结构，差异较大。难以统一。 如果强制去统一，语言又会变得难以掌握，编译程序较大，编译效率低。
  人们对语言基础结构看法不同，如 有的人觉着GOTO语句能让语言更灵活 应该保留。而有的人觉着它会降低代码可读性 应取消。
  **即使同一种高级语言在不同厂家的机器上也不能完全通用。**各厂家机器的 I/O设备种类和数量，子程序结构，寻址空间，操作系统等 并不相同。 部分厂家为发展自己特色，常用自己的 “专有语言” 。为节省储存空间，提高执行速度，在高级语言软件中部分嵌入汇编语言，使同种高级语言难以移植。
  语言习惯问题，人们不愿意抛弃自己习惯的语言，不愿意抛弃自己长期积累的经验 和 在原有语言编写已被实践证明正确的软件。
  为此，各种机器都得适配较多通用的高级语言编译系统。同一种高级语言，各个机器的编译系统软件不同，无法通用，不利于系统结构的发展</description>
    </item>
    
    <item>
      <title>计算机系统设计的主要任务和方法1.3(Addition)</title>
      <link>https://itscola.github.io/blog/5.computersystemframework-1.3addition/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/5.computersystemframework-1.3addition/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
计算机系统设计的主要任务和方法 知道了计算机系统的层次结构，知道了机器级。这篇文章，将基于 机器级分层原理 来讲述 计算机系设计的方法。
主要任务 计算机系统设计的主要任务包括 系统结构、组成、实现。 这些分别是什么，以及有什么区别，请看我之前的文章。
计算机系统结构的概念
计算机的组成和实现以及它们之间的关系
这里简单概括一下。
 计算机系统结构又称计算机层次结构，是传统机器级的系统结构。它是软硬件的交界面 它研究的内容是   传统机器级上界面的定义。 软硬件功能的分配。 为各机器级提供应有应遵循的规范。   计算机组成 是计算机系统结构逻辑的实现，包括内部控制流，数据流的组成，逻辑设计等。
  计算机实现 是计算机组成的物理实现，它主要研究 器件技术 和 微组装技术 。以器件技术为主导。
  计算机设计的主要方法 计算机设计的主要方法有三种。分别是 从上往下，从下往上，从中间向两边。第三种方法为目前最佳的设计方式。
从上往下 也称“从顶向低”设计。
它的方法为：
先考虑满足应用要求，定好面向应用的那个虚拟机器级的特性和环境，在逐级向下设计。
它的特点为：
 每设计下一级，都要考虑对下一级的优化。【优化问题】 要串行设计，设计周期长。【设计效率】 通用机的应用对象和环境不停改变，一旦改变，软硬件很快就会不适应，系统效率极具下降。【应用易改变】 其传统机器级和微程序机器级，都在已有机器中选型。通常不专门设计。【不专门设计】 实际很难做到面向应用优化。【难优化】  从下往上 也称 “由底向顶”设计。
方法：先不管应用要求，按照已有机器的特点来做器件，将传统机器机器级和微程序机器级研发。然后适配不同领域的操作系统和编译系统软件，采用合适的系统软件和算法来满足应用需求。
特点：
 硬件不能改变，仅靠设计软件来被动适配硬件。有时候仅仅需要稍微更改或增加硬件的功能就能大大简化软件设计，都做不到。【硬件不可变】 软硬件脱节，软件得不到硬件的支持而变得繁杂，部分机器指标不真实。【软硬件脱节】 串行设计，会延长设计周期。同样已经很少使用。【设计周期长】  由中间开始 方法：由中间开始向两边设计。
这是通用机通常使用的方法。</description>
    </item>
    
    <item>
      <title>向下兼容 向上兼容 向前兼容 向后兼容</title>
      <link>https://itscola.github.io/blog/updownbeforeafter/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/updownbeforeafter/</guid>
      <description> 向下兼容 向上兼容 向前兼容 向后兼容 有没有听说过，向后兼容？ 其实有向“前后上下”兼容。 其实这些概念很简单。
向上兼容（基本要求） 向上兼容是指，当我们在一个计算机上开发程序，然后换了台（同一系列）性能更好，档次更高的计算机。然后程序依然能兼容（完美运行）。
向上兼容：在低档次计算机开发的程序，在高档次计算机依然兼容。
向上兼容是开发一个程序的必要要求。
向下兼容 向下兼容则和向上兼容相反，当我们在一个计算机上开发程序，换了台（同一系列）低性能、低档次的计算机，程序依然能兼容。（完美运行）。
向下兼容：在高档次计算机开发的程序，在低档次计算机依然兼容。
向前兼容 向前兼容是指，假如我在2021年出的计算机上开发一个程序。在2018年的计算机上依然兼容（完美运行）。
向前兼容：在一台计算机上开发的程序，在之前的计算机依然兼容。
向后兼容（基本要求） 向后兼容是指，假如我在2018年出的计算机上开发一个程序。在2020年的计算机上依然兼容（完美运行）。
向前兼容：在一台计算机上开发的程序，在之后的计算机依然兼容。
向后兼容是开发一个程序的必要要求。
总结  向前兼容，向后兼容 指的是时间前后兼容问题。 向上兼容，和向上兼容 指的是计算机档次兼容问题。 向上兼容和向后兼容比较容易做到。这也是程序开发的基本要求。（特别是向后兼容）  </description>
    </item>
    
    <item>
      <title>计算机系统软硬件取舍与定量设计1.3</title>
      <link>https://itscola.github.io/blog/4.computersystemframework-1.3/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/4.computersystemframework-1.3/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
计算机系统软硬件取舍与定量设计  计算机的功能可以通过硬件实现，也可以通过软件实现。但不存在纯硬件实现或纯软件实现的计算机。
 这意味着什么？ 意味着在设计一台计算机时，功能即可以使用软件实现，又可以使用硬件实现。它们的使用边界变得模糊。 这是要讲的 软硬件取舍
在设计一台计算机时，我们要怎么样做，才能做到好？ 我们需要一些依据，来帮助更好的设计。 这是要讲的 定量设计原理
以及作为使用者，该如何判断一个计算机到底如何？ 这是要讲的 计算机性能描述（使用者角度）
一 软硬件取舍 1. 成本方面考虑 作为计算机设计者，成本是一个很重要的方面。它包括了软硬件的 设计成本 和 制造成本。
根据我曾经的文章 (这里不再重复解释，请先去看这篇文章)
软件实现和硬件实现的比例关系与推导过程
我们可以得知：
 用软件来实现更灵活，更强大，设计和重复生产费用更低。但效率远不如硬件实现。 用硬件实现效率更高，性能更高，但设计和生产费用较为高昂，灵活性不如软件。 硬件对研发与制造费用极其高，费用为软件的100倍是完全可能的。  以及结论：
 也就是说 一个功能 经常用到 经常出现 才更适合用硬件。 当我们要生产的设备产量越大，我们用硬件的比例就可以越多(越适合)。 并不是用硬件实现功能的比列越大越好。这还要考虑资金等问题。  2. 取舍基本原则 加上成本方面与其它方面，可以有以下几点取舍原则。
  在现有硬、器件条件下，应从实现费用，速度，其它性能性能 综合考虑，以获得高的性能价格比。【性能价格比】 应考虑采用或可能采用组成技术，使其不要过多或不合理地限制各种实现和组成技术。【组成技术】 不能光从“硬”的角度去考虑如何便于应用组成技术的成功 和 发挥器件技术的发展，还要从“软”的角度把 如何为 编译和操作系统的实现 以及 高级语言程序的设计 提供更多，更好的硬件支持 放在首位。【兼容度】   第一点是，要从费用、速度、其它性能综合考虑获得性价比。</description>
    </item>
    
    <item>
      <title>软件实现和硬件实现的比例关系与推导过程</title>
      <link>https://itscola.github.io/blog/softwareandhardwareimplenment/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/softwareandhardwareimplenment/</guid>
      <description>软件实现和硬件实现的比例关系 通常，同一个功能，我们既可以用软件实现也可以用硬件来实现。
用软件来实现更灵活，更强大，设计和重复生产费用更低。但效率远不如硬件实现。
用硬件实现效率更高，性能更高，但设计和生产费用较为高昂，灵活性不如软件。
（通常不存在只用软件实现或只用硬件实现的类计算机设备）
通过这篇文章，你将了解到，计算机 手机 设备 等设计 软硬件取舍，以及设备产量与硬件费用的关系。
（生产量越多，设备在一定资金下，能用的硬件越多？）
生产软硬件分别需要支付的费用 生产软硬件 都需要 研发费用(Design) 和 生产费用(Manufacture)。
软件通常需要多次设计(研发)，硬件通常只需要设计一次。
我们设硬件每次的研发费用为D(hardware) 简称 D(h). 同时设每次重复生产费用为M(h)。
设软件研发每次的研发费用为 D(software) 简称 D(s). 同时设每次重复生产费用为 M(s)。
D(h) 约等于 100D(s). 每研发一个硬件的费用 大概为 研发100个软件的费用。 M(h)约等于 100M(h). 每生产一个硬件的费用 大概为 生产100个软件的费用。
(可以说硬件和软件比 是非常贵的。)
实际生产费用 我们设生产了V个设备，同时设研发了C次。
设一个功能在一台设备上出现了R次。
每台设备的软件生产费用 那么每台设备 软件实际生产费用为 C * D(s) / V + R * M(s).
指的是 研发次数 * 研发软件费用 / 设备生产数 + 功能在设备上出现次数 * 软件重复生产费用
每台设备的硬件生产费用 那么每台设备 硬件实际生产费用为</description>
    </item>
    
    <item>
      <title>计算机的组成和实现以及它们之间的关系1.2.2</title>
      <link>https://itscola.github.io/blog/3.computersystemframework-1.2.2/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/3.computersystemframework-1.2.2/</guid>
      <description> A. 计算机系统结构 组成 和 实现 2 要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列并不是普通的“笔记”，而是以我个人的理解，来讲解 计算机系统结构。 不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
1. 计算机组成 1. 什么是计算机组成 计算机组成就是 计算机系统结构 的逻辑实现。 包括机器级内部的控制流 数据流的组成 逻辑设计等。
 着眼于机器级内部各事件的排序方式，控制结构，各部件的功能及其联系。
 比如要处理一个事件，事件的处理顺序，方式 （逻辑）。这都属于计算机组成。
计算机组成对于系统结构来说是透明的，
2. 计算机组成的研究 它要研究的是：如何在一定资金和性能下，做到更好更合理的组成计算机，实现所需的系统结构。
2. 计算机实现 1. 什么是计算机实现 计算机实现是计算机组成的物理实现。
电路怎么设计，采用什么工艺制作，器件集成度和速度 ，模块底板的划分和连接 &amp;hellip;&amp;hellip; 这都属于 计算机实现。（主要是一些能看得到摸得着的东西）
计算机的实现对于计算机系统结构来说也是透明的。
2. 计算机实现的研究（着眼于） 它主要着眼于 器件技术 和 微组装技术，
其中器件技术起主导地位。
3. 计算机系统结构，组成，实现的互相关系和影响 1. 相互关系  它们互不相同，却互相影响。 相同结构的计算机，可以有多种组成方式。 相同组成的计算机，可以有多种实现方式。  （就比如系统结构相同，但是逻辑实现并不一定相同。比如相同的系统，当随着版本更新，实现逻辑可能有变化）
（又比如逻辑实现相同，但是物理实现可能不同。比如芯片制作工艺不一样。）
2. 相互影响  计算机组成向上决定于 计算机系统结构 ，向下受限于实现技术。 应当在所需条件下，应在计算机组成 和 实现之间做权衡。 组成也会影响结构，没有计算机组成的进步，就没有计算机系统结构的进步。 计算机系统结构不但要考虑上级的算法，软件，界面 支持。还要考虑下级的可能采用和准备采用的组成和实现技术。 不同时期不同系统，结构，组成，实现之间也有差异。在某些系统中作为结构的内容，在另一些系统中可能是组成和实现技术的内容。  </description>
    </item>
    
    <item>
      <title>计算机系统结构的概念1.2.1</title>
      <link>https://itscola.github.io/blog/2.computersystemframework-1.2.1/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/2.computersystemframework-1.2.1/</guid>
      <description>A. 计算机系统结构 和 组成 和 实现 1 要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列并不是普通的“笔记”，而是以我个人的理解，来讲解 计算机系统结构。 不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
1. 什么是计算机系统结构 1. 透明性 先要清楚一个概念，什么是透明性？
透明性： 一些客观存在的属性或事物，在某个角度看不到，那么就说那些属性或事物对于这个角度是透明的。
举个例子：我们在使用操作系统时，我们是看不到 组成这台计算机的零件 是如何运作的。
可以说 “组成这台计算机的零件 是如何运作的”对于我们从使用操作系统这个角度，是透明的。
2. 透明性的作用 理解了透明性，那大概能猜出这样的作用了。
 简化所在机器级的设计。(好处) 透明也会带来一些无法控制的问题。(坏处)  我们在一个角度上，不怎么需要太在意对我们透明的事物属性。这大大简化了我们的使用。
但是有时候，我们在一个角度上，必须要在意对我们透明的事物属性，这会给我们带来不利。这也是无法控制的问题。
3. 系统结构 及其研究 在研究计算机系统结构前，先来了解下什么是 系统结构。
系统结构：以计算机系统结构的角度说，系统结构指的是，计算机系统中 各机器级界面的定义 以及上下功能的分配。
什么意思？ 各机器级上的界面，定义为什么。 上下级功能分配了什么。我们将这 定义 分配 称为系统结构。
系统结构的研究： 在定义 和 分配时 我们要对 某些事物属性进行划分。哪些属于这里，哪些属于那里。换言说，我们就是在 研究 哪些属性应该透明，哪些属性不应该透明。
4. 计算机系统结构 及其研究 概念： 计算机系统结构 是 系统结构 的一部分。
它又被称为 计算机系统的结构体系。 它指的就是 传统机器语言机器级 的系统结构。</description>
    </item>
    
    <item>
      <title>计算机系统层次结构1.1</title>
      <link>https://itscola.github.io/blog/1.computersystemframework-1/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/1.computersystemframework-1/</guid>
      <description>A.计算机系统层级结构 这一篇，来说下计算机的 基础理论知识。
它属于计算机系统结构的内容. 关于计算机系统结构，可能会做一个系列。
一. 计算机系统的层次 1. 概念 通用计算机系统层次 分为6个级，每个级我们称之为 “机器级”。 距离人的使用越近的，越为高级，反之，越远，越为低级。
从高级到低级，分别有 应用语言机器级，高级语言机器级，汇编语言机器级，操作系统机器级，传统机器语言机器级，微程序机器级。
记得有张图，有个大学教授问“vscode是什么语言？”，引起很多人“嘲讽”。 我认为它大概问的就是机器级。 应回答 “应用语言”。
2. 分机器级的意义 透明的概念：在分级的情况下，任意一级(有下一级的情况下)的下级，对于这级通常都是不必太关心的。但下级是客观存在的。我们就说,对于这一级,那些下一级都是透明的.
举个例子：我们要用java语言开发一个程序，我们通常不需要在乎，这个电脑用的什么显卡，用的什么主板，用的什么处理方式。 这些对于我们来说都是透明的。
二.机器级的实现 1.实现的两种方式 机器级等实现主要通过两种方式。
翻译 或 解释 或是 解释翻译 并用。
翻译技术：先用转换器，将上一级机器级的程序翻译为下一级等效的程序。然后在下一级机器级继续实现。
举个例子：C语言程序会由编译程序翻译成汇编程序，汇编程序由汇编器翻译成机器语言程序。
解释技术：用第一级的机器级上的一串语句或指令来仿真高级机器级的一条语句，或指令功能。（运行过程中 逐条逐句的解释）
例子：JavaScript由浏览器解释执行，如果有错误，通常不会影响到前面的代码。
2.翻译和解释的特点  翻译往往是所有程序做完再执行，而解释是一边解释一边执行。 解释过程中 解释一条 运行一条 灵活性更高。  什么是编译器,解释器? (一文理解编译型和解释型语言)
3.机器级间的特点  应用语言 程序通过程序包翻译成高级语言程序。 高级语言 程序通过编译程序编译成汇编语言程序。（或是 中间代码，再或是 机器语言程序） 汇编语言 程序通过汇编程序翻译成机器语言程序。 操作系统 通过机器语言程序 解释 控制语句作业。 传统机器机器级由 微程序(固件) 实现。 而前四个都由软件实现。  固件是指通过硬件实现软件功能。 如常见的BIOS ，它通常不会改变，但又不是不可改变。</description>
    </item>
    
    <item>
      <title>用多项式回归, 预测国家在2021,2035年的GDP</title>
      <link>https://itscola.github.io/blog/gdpofchinain2035/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/gdpofchinain2035/</guid>
      <description>欢迎来到这篇文章, 我将会通过机器学习技术, 来预测我们国家在2035年的GDP.
当然, 预测只是预测, 并不代表准确数据. 但会有一定的参考性.
所使用语言为Python.
GDP数据 我们要让机器学习模型学习的数据, 将会来自 国家数据.
数据导入 import matplotlib.pyplot as plt import numpy as np import pandas as pd Dataset = pd.read_csv(&#39;ChinaGDP.csv&#39;) X = Dataset.iloc[:,:-1].values y = Dataset.iloc[:,-1].values (由于我们会用到线性回归的函数,已经包含了特征缩放的步骤 所以此处不需要再特征缩放了)
观察数据 下面我们将数据画在图上, 更直观的观察我们的GDP数据.
plt.scatter(X, y) plt.xlabel(&#39;Year&#39;) plt.ylabel(&#39;GDP of China&#39;) plt.title(&#39;GDP&#39;) plt.show() 可以看到, 这令人激动的上升趋势.
很明显, 我们不能使用线性回归来拟合模型, 因为它并不呈线性.
所以我们将使用多项式回归 , 来拟合我们的模型.
(这边我们只需要将数据展示在图上观察数据来判断模型的质量, 所以我们目前不拆分成 训练集 测试集)
拟合数据 下面我们将多项式回归拟合.
from sklearn.preprocessing import PolynomialFeatures Poly_regressor = PolynomialFeatures(degree=2) Poly_X = Poly_regressor.</description>
    </item>
    
    <item>
      <title>多元线性回归的概念 (Multiple linear regression)</title>
      <link>https://itscola.github.io/blog/what-is-multiple-linear-regression/</link>
      <pubDate>Wed, 10 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/what-is-multiple-linear-regression/</guid>
      <description>关于文章 这篇文章较短, 是因为关于线性回归的概念, 都放在了上一篇文章.
在阅读之前，你大概率需要这个系列的之前文章的基础。
文章追求通俗易懂，让没有编程基础的读者也能看懂，所以不会用很多专业用语。
多元线性回归 假如我们要去租房，我们手里有各个房屋的各种数据。此时，我们想预测，根据我们的需求，租到的房子应该在多少钱。
一个简单的方式就是，建立多元线性回归模型，学习这些数据，然后我们可以通过我们的要求 预测 房价应该在多少。
什么是多元线性回归 我们说 一元线性回归就是 一个自变量 对应着 一个因变量。
那么 多元线性回归就是 多个自变量 对应着 一个因变量。
多元线性回归模型 这个模型可以表达为:
 y= B0 + B1*X1 + B2*X2 + B3*X3 ... 有多少个自变量，就会有多少个B*X。
再看 一元线性回归
y= B0 + B1*X
它只有一个自变量
很遗憾的是，由于多元线性回归是多元模型，它可能有很多唯。因此我们无法画出它的图像。
是否为线性 线性主要是看因变量y的形式，是否为 呈线性。B1*X1+B2*X2</description>
    </item>
    
    <item>
      <title>一元线性回归的概念 (A linear regression)</title>
      <link>https://itscola.github.io/blog/what-is-a-linear-regression-equation/</link>
      <pubDate>Thu, 04 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/what-is-a-linear-regression-equation/</guid>
      <description>欢迎, 这是机器学习系列的第二篇文章 此文章是我在 Machine Learning 学习过程中以自己的理解做的总结
文章追求以最通俗的方式, 把机器学习带给所有人爱好者.
一元线性回归 我们手里有一家公司的员工 工资经验 和 对应薪水 数据, 假如我们有3.4年工作经验, 那我们提出多少工资比较好呢 ?
阅读之前, 确保你已经读懂了上一篇文章.
什么是一元线性回归 你可以理解为 我们通过 最合适的方式 把零散的数据变成规律的线(面). 从而用来进行对 因变量(我们需要预测的数据) 预测.
最合适的方式? 通过 某种函数关系(后面会讲) 得到的最为公平的 理想数据 它是规律的线 面.
一元指的是 这些数据只有一个自变量(特征). 例如上方的图片, 这个数据只有 一个自变量(工作经验(年)) 一个因变量(工资).
当然, 有一元 还会有 多元, 这就是后面的文章了.
一元线性回归模型 什么是模型? 模型是我们上一篇提到过的 &amp;ldquo;机器学习模型&amp;rdquo; 你可能不记得了, 这边再说一下.
如果我们想实现通过 自变量(特征) 来预测 因变量. 那么我们需要建立一个模型, 先让 机器学习模型 进行学习, 然后我们就可以用 机器学习的成果 来用 自变量(特征) 预测 因变量.
一元线性回归模型, 就说一个简单的模型, 我们通常可以直接使用.
这个模型可以表达为:</description>
    </item>
    
    <item>
      <title>机器学习的概念 (Machine Learning)</title>
      <link>https://itscola.github.io/blog/what-is-machine-learning/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/what-is-machine-learning/</guid>
      <description>此文章是我在 Machine Learning 学习过程中以自己的理解做的总结
文章追求以最通俗的方式, 让所有阅读者理解机器学习的概念.
什么是机器学习？ 当我们建立一个机器学习模型。机器学习模型中会包含了自变量（特征），和因变量。 然后基于模型让机器学习数据，之后我们可以做到 通过自变量 (特征) 让机器学习告诉我们因变量。 这就是机器学习。
总结来讲, 机器学习就是让机器学习数据之间的关系, 我们可以用学习到的结果,对新数据进行预测.
简单的例子 假如我们有一些用户数据。其中每个用户的数据包括了 年龄 薪水 地区 和 是否该买了我们的产品。 我们可以通过机器学习 实现 只要有 年龄 薪水 地区 就可以让机器预判出 是否会购买我们的产品。
机器学习是未来？ 这个问题，与其说一大堆，不如由你自己判断。对于它的好坏，我们都应该理性看待。而不是人云亦云。
它和深度学习 人工智能的关系 人工智能包括了机器学习 而机器学习又包括了深度学习。
人工智能 &amp;gt; 机器学习&amp;gt; 深度学习
人工智能: 使计算机能模拟人的思维.
它和深度学习的区别 深度学习的实现 借鉴了人脑的神经元。它通常用于处理很复杂的事情。比如很多生活中的事情，要考虑很多因素。
深度学习可以自动提取 特征(因变量). 而机器学习需要手动提取 特征(因变量).</description>
    </item>
    
    <item>
      <title>什么是编译器,解释器? (一文理解编译型和解释型语言)</title>
      <link>https://itscola.github.io/blog/compiler-and-interpreter/</link>
      <pubDate>Thu, 25 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/compiler-and-interpreter/</guid>
      <description>编程语言  我们所用的程序都是用某种语言写的, 但是它会先被翻译成能被计算机执行的语言之后才能运行. 通常人们会通过它用了 编译器(compiler) 还是 解释器(interpreter) 来判定他解释型还是编译型语言. 如java这种又用了 编译器 又用了 解释器 通常被我们称为 半解释半编译型语言.  编译器和解释器 编译器 编译器就是一个程序.它会把我们的 源代码写的程序 翻译成 一种等价的 另一种语言 写的程序.
在它进行翻译的过程中, 还会报告它在源代码中发现的错误.
 源代码写的程序 -编译器-&amp;gt; 目标程序
目标程序就可以处理 用户的输入 得到对应的 输出  解释器 解释器不会进行翻译来生成目标程序, 而是直接通过 用户的输入 和 源程序 来生成目标程序.
 源代码写的程序 + 用户的输入 -解释器-&amp;gt; 目标程序  优缺点  通过编译器生成的目标程序 来处理用户的输入 通常比用一个解释器快很多. 通过解释器来运行 由于它是逐个语句来执行 错误诊断效果通常比编译器好.  Java的半编译半解释 Java就是个半编译半解释形语言 java源程序会被编译成字节码(bytecode)(中间代码),然后再由JVM(java虚拟机) 解释执行. 也通过中间代码 实现了跨平台.
补充 在编译器和解释器前后, 还会有一些其他步骤. 这边主要聊编译器和解释器.</description>
    </item>
    
    <item>
      <title>Gradle快速掌握基础用法</title>
      <link>https://itscola.github.io/blog/gradle-basic/</link>
      <pubDate>Wed, 24 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/gradle-basic/</guid>
      <description>Why Gradle？  Gradle是一款自动化构建项目的开源工具。 它使用Groovy来声明项目设置。和maven相比，它抛弃了繁杂的xml配置，同时配置文件做到简洁美观。 很多开源项目 需要使用gradle构建。 Java应用为主 目前支持 Java、Groovy、Kotlin和Scala.  下载并配置 下载地址： 点击下载 这里下载all版本，包含了源码、文档、示例等内容。
配置环境变量：  将压缩包解压到任意目录. 打开环境变量配置，添加系统变量到这个目录，命名为Gradle_Home。 选择用户变量中的path，添加%Gradle_Home%/bin 。 在cmd中输入 gradle -v 如果出现显示的gradle版本，代表配置成功。  使用本地maven仓库 如果每个项目都要从maven仓库下载一次依赖, 那么将会占用很多空间, 并影响开发效率. 我们可以通过配置环境变量, 先让gradle找本地下载过的依赖, 如果没有 那再去maven仓库下载.
首先选择一个本地的maven仓库文件夹路径. 然后打开环境变量配置, 在系统变量新建一个变量 变量名为 GRADLE_USER_HOME 变量值为上一步选择的本地 maven仓库文件夹.
今后gradle会先从本地maven仓库找jar包 , 找不到再去maven仓库下载到本地maven仓库.
IDEA创建gradle项目与配置 在Idea中创建Gradle项目 配置build.gradle  主要配置内容:
   repositories主要是选定的maven仓库 默认为maven中央仓库
当然你也可以添加仓库 可以参考 阿里的Maven仓库镜像 的教程来设定  在denpdencies添加jar坐标(依赖):   从你所添加的maven仓库添加:
这里用默认的 maven中央仓库. 首先打开你所要添加的仓库页面, 搜索你要添加的jar. 点击search. 找到后点击.</description>
    </item>
    
  </channel>
</rss>
