<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>硬件 on White_cola Blog</title>
    <link>https://itscola.github.io/tags/%E7%A1%AC%E4%BB%B6/</link>
    <description>Recent content in 硬件 on White_cola Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>志存高远 , 以梦为马.</copyright>
    <lastBuildDate>Mon, 26 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://itscola.github.io/tags/%E7%A1%AC%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机系统设计的主要任务和方法1.3(Addition)</title>
      <link>https://itscola.github.io/blog/5.computersystemframework-1.3addition/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/5.computersystemframework-1.3addition/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统设计的主要任务和方法 知道了计算机系统的层次结构，知道了机器级。这篇文章，将基于 机器级分层原理 来讲述 计算机系设计的方法。
主要任务 计算机系统设计的主要任务包括 系统结构、组成、实现。 这些分别是什么，以及有什么区别，请看我之前的文章。
计算机系统结构的概念
计算机的组成和实现以及它们之间的关系
这里简单概括一下。
 计算机系统结构又称计算机层次结构，是传统机器级的系统结构。它是软硬件的交界面 它研究的内容是   传统机器级上界面的定义。 软硬件功能的分配。 为各机器级提供应有应遵循的规范。   计算机组成 是计算机系统结构逻辑的实现，包括内部控制流，数据流的组成，逻辑设计等。
  计算机实现 是计算机组成的物理实现，它主要研究 器件技术 和 微组装技术 。以器件技术为主导。
  计算机设计的主要方法 计算机设计的主要方法有三种。分别是 从上往下，从下往上，从中间向两边。第三种方法为目前最佳的设计方式。
从上往下 也称“从顶向低”设计。
它的方法为：
先考虑满足应用要求，定好面向应用的那个虚拟机器级的特性和环境，在逐级向下设计。
它的特点为：
 每设计下一级，都要考虑对下一级的优化。【优化问题】 要串行设计，设计周期长。【设计效率】 通用机的应用对象和环境不停改变，一旦改变，软硬件很快就会不适应，系统效率极具下降。【应用易改变】 其传统机器级和微程序机器级，都在已有机器中选型。通常不专门设计。【不专门设计】 实际很难做到面向应用优化。【难优化】  从下往上 也称 “由底向顶”设计。
方法：先不管应用要求，按照已有机器的特点来做器件，将传统机器机器级和微程序机器级研发。然后适配不同领域的操作系统和编译系统软件，采用合适的系统软件和算法来满足应用需求。
特点：
 硬件不能改变，仅靠设计软件来被动适配硬件。有时候仅仅需要稍微更改或增加硬件的功能就能大大简化软件设计，都做不到。【硬件不可变】 软硬件脱节，软件得不到硬件的支持而变得繁杂，部分机器指标不真实。【软硬件脱节】 串行设计，会延长设计周期。同样已经很少使用。【设计周期长】  由中间开始 方法：由中间开始向两边设计。
这是通用机通常使用的方法。
特点：</description>
    </item>
    
    <item>
      <title>计算机系统软硬件取舍与定量设计1.3</title>
      <link>https://itscola.github.io/blog/4.computersystemframework-1.3/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/4.computersystemframework-1.3/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
计算机系统软硬件取舍与定量设计  计算机的功能可以通过硬件实现，也可以通过软件实现。但不存在纯硬件实现或纯软件实现的计算机。
 这意味着什么？ 意味着在设计一台计算机时，功能即可以使用软件实现，又可以使用硬件实现。它们的使用边界变得模糊。 这是要讲的 软硬件取舍
在设计一台计算机时，我们要怎么样做，才能做到好？ 我们需要一些依据，来帮助更好的设计。 这是要讲的 定量设计原理
以及作为使用者，该如何判断一个计算机到底如何？ 这是要讲的 计算机性能描述（使用者角度）
一 软硬件取舍 1. 成本方面考虑 作为计算机设计者，成本是一个很重要的方面。它包括了软硬件的 设计成本 和 制造成本。
根据我曾经的文章 (这里不再重复解释，请先去看这篇文章)
软件实现和硬件实现的比例关系与推导过程
我们可以得知：
 用软件来实现更灵活，更强大，设计和重复生产费用更低。但效率远不如硬件实现。 用硬件实现效率更高，性能更高，但设计和生产费用较为高昂，灵活性不如软件。 硬件对研发与制造费用极其高，费用为软件的100倍是完全可能的。  以及结论：
 也就是说 一个功能 经常用到 经常出现 才更适合用硬件。 当我们要生产的设备产量越大，我们用硬件的比例就可以越多(越适合)。 并不是用硬件实现功能的比列越大越好。这还要考虑资金等问题。  2. 取舍基本原则 加上成本方面与其它方面，可以有以下几点取舍原则。
  在现有硬、器件条件下，应从实现费用，速度，其它性能性能 综合考虑，以获得高的性能价格比。【性能价格比】 应考虑采用或可能采用组成技术，使其不要过多或不合理地限制各种实现和组成技术。【组成技术】 不能光从“硬”的角度去考虑如何便于应用组成技术的成功 和 发挥器件技术的发展，还要从“软”的角度把 如何为 编译和操作系统的实现 以及 高级语言程序的设计 提供更多，更好的硬件支持 放在首位。【兼容度】   第一点是，要从费用、速度、其它性能综合考虑获得性价比。</description>
    </item>
    
    <item>
      <title>阿姆达尔定律(计算机加速比)</title>
      <link>https://itscola.github.io/blog/amdhallaw/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/amdhallaw/</guid>
      <description>阿姆达尔定律(计算机加速比) 当我们通过改进计算机来对计算机进行加速时，究竟加速了多少？
我们对计算机的部分硬件进行重量级提升，花费大量资金，但计算机性能并没有显著提升，这是为什么？
这就是这篇文章要讲的话题，阿姆达尔定律。
阿姆达尔定律的背景 阿姆达尔定律 由 阿姆达尔在1967年提出。他是IBM360系列机的主要设计者。
定理可以确定对系统中性能难以提升的部分改进后的改进程度。
整个定律由数学公式计算，具有一定参考价值。从定律中，也可以得到一些对计算机改进方面的结论。
也许现实中并不好测量然后计算，但它带给我们的结论才是最重要的。
阿姆达尔定律的推导过程 提示：如果对推导过程不感兴趣，可以直接看结论。
第一点，要知道的是。
加速比 = 系统改进后的性能 / 系统改进前的性能 = 改进前的总执行时间 / 改进后的总执行时间
看不懂？ 那就对了，我们继续往下。
第二点要知道的是：
改进前￼的总执行时间 = 不可改进部分的执行时间 + 可改进部分的执行时间
改进后的总执行时间 = (1 - 可改进比例) * 总执行时间 + (可改进比例 * 总执行时间)/部件加速比
 首先，我们改进一个机器，通常不是全部改进，而是只改进一部分。所以有了可改进比例 和 不可改进比例。
那么来看第二条，
我们的可改进比例有了，那不可改进比例呢？ 是不是就是 1 - 可改进比例。
再来看 (可改进比例 * 总执行时间) / 部件加速比
这个 部件加速比 是什么？
我们试着去掉它 得到
(可改进比例 * 总执行时间)
一目了然了，去掉后就是 我们改进前的 可改进部分的总执行时间 。</description>
    </item>
    
  </channel>
</rss>
