<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>硬件 on White_cola Blog</title>
    <link>https://itscola.github.io/tags/%E7%A1%AC%E4%BB%B6/</link>
    <description>Recent content in 硬件 on White_cola Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>志存高远 , 以梦为马.</copyright>
    <lastBuildDate>Mon, 26 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://itscola.github.io/tags/%E7%A1%AC%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[1.4]应用 器件 的发展对系统结构的影响1.4-2</title>
      <link>https://itscola.github.io/blog/7.computersystemframework-1.4-2/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/7.computersystemframework-1.4-2/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
应用发展对计算机系统的影响 应用的需求时计算机发展的最大动力。
（没有应用需求，很难有动力）
由于需求，计算机系统结构才不断地提高性能。
需求：
多媒体：大型游戏，高清视频 网络应用：云计算，防火墙，高性能路由器 科学计算：机器学习，天气预报
其中大型游戏是促进个人电脑更新换代的最大动力。
器件发展对系统结构的影响 1. 非用户片，现场片，用户片 的定义。 非用户片：
也称“通用片”，其功能是由器件厂家生产时固定的，器件的用户只能使用，不能更改器件的内部功能。
现场片：
用户可根据需求更改器件内部功能。在20世纪70年代中期出现。使用灵活，功能强，可取代硬联组合网络，还可以构成时序网络。
如：可编程只读储存器PROM（BIOS所用）、现场可编程逻辑阵列FPLA等。
用户片：
专门按照用户要求，生成高集成度VLSI器件。 设计周期长，设计费用高，销量小，成本高。
（如果是完全按照需求设计的用户片，称为全用户片。）
苹果公司直呼内行
2. 器件发展是推动系统结构和组成前进的因素 电子管 -&amp;gt; 晶体管 -&amp;gt; 小规模集成电路 -&amp;gt; 大规模集成电路 -&amp;gt; 超大规模集成电路
非用户片 -&amp;gt; 现场片 -&amp;gt; 用户片
制造工艺也在进步。
国外的光刻机是好几个国家联合研发的。但它们不愿意卖给我们国家。我们必须研发自己的光刻机。这对我们国家的未来真的十分重要。尽管非常非常艰难。
工艺越强大 ：集成度上升 功耗下降 主频上升 性能上升。
3. 器件发展改变了逻辑设计的方法 过去的设计逻辑：专注逻辑简化 和 各种节省。（节省功耗、降低成本、提高速度） （对现在的VLSI不适应）
VLSI是超大规模集成电路(Very Large Scale Integration)的简称
目前的设计逻辑：
最主要是应用。（微汇编，微高级语言，计算机辅助设计软件的方法来设计）
对于用户片的计算机 ，机器设计 和 芯片设计 密不可分，机器设计的关键是芯片设计。</description>
    </item>
    
    <item>
      <title>[1.4]软件的发展对系统结构的影响1.4-1</title>
      <link>https://itscola.github.io/blog/6.computersystemframework-1.4-1/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/6.computersystemframework-1.4-1/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
软件的发展对系统结构的影响 软件发展对系统结构的影响，主要体现在可移植性方面。
1. 软件的可以移植性 可移植性的概念：一款程序不经修改，或只需要少量的修改，就可以由一台计算机移植到另一台计算机。同一软件应用于不同环境。
一台计算机移植到另一台计算机，不经修改，或修改的很少，我们就说 可移植性 越好。反之 越差。
每次发布新硬件，都要考虑可移植性，可移植性越高越好。
假如我发布了一个显卡，性能比市面上显卡性能普遍较高，但是显卡的 可移植性很差，不兼容市面上所有程序。也就是说程序完全需要从0设计。 通常是不会有生命力的。
2. 可移植性特点  软件能长期使用，不会因为机器更新需要重新编写。 大大减少了编程软件的工作量。 能迅速用上新的硬件技术，更新系统，让新系统立即发挥效能。 软件设计者将更有精力开发全新的软件。  实现可移植性的几种方法 实现可移植性主要有三种方法。
1. 统一高级语言 统一高级语言，是一种理想的软件移植方法。
让所有程序员使用统一的高级语言，这样只需要各个操作系统对这种语言适配（操作系统的全部或一部分使用这种语言），即可实现软件的高可移植性。
但直到如今，没有一种是对各种应用真正通用的高级语言。
又很多语言去尝试，比如跨平台比较优秀的 haxe语言，它可以编译成Java，CPP，JavaScript，C#，JVM，PHP，Python&amp;hellip;&amp;hellip; 。以及几乎支持所有常见平台。实现真正跨平台。但目前还是小众语言，原因也如下列所说。 Haxe - Github
原因如下：
（如果理解加粗字体，就可以不用看后面的内容）
  不同用途要求语言语法不同，如Julia语言面向科学计算，Java面向程序开发。它们的语义语法结构，差异较大。难以统一。 如果强制去统一，语言又会变得难以掌握，编译程序较大，编译效率低。
  人们对语言基础结构看法不同，如 有的人觉着GOTO语句能让语言更灵活 应该保留。而有的人觉着它会降低代码可读性 应取消。
  **即使同一种高级语言在不同厂家的机器上也不能完全通用。**各厂家机器的 I/O设备种类和数量，子程序结构，寻址空间，操作系统等 并不相同。 部分厂家为发展自己特色，常用自己的 “专有语言” 。为节省储存空间，提高执行速度，在高级语言软件中部分嵌入汇编语言，使同种高级语言难以移植。
  语言习惯问题，人们不愿意抛弃自己习惯的语言，不愿意抛弃自己长期积累的经验 和 在原有语言编写已被实践证明正确的软件。
  为此，各种机器都得适配较多通用的高级语言编译系统。同一种高级语言，各个机器的编译系统软件不同，无法通用，不利于系统结构的发展</description>
    </item>
    
    <item>
      <title>计算机系统设计的主要任务和方法1.3(Addition)</title>
      <link>https://itscola.github.io/blog/5.computersystemframework-1.3addition/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/5.computersystemframework-1.3addition/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
计算机系统设计的主要任务和方法 知道了计算机系统的层次结构，知道了机器级。这篇文章，将基于 机器级分层原理 来讲述 计算机系设计的方法。
主要任务 计算机系统设计的主要任务包括 系统结构、组成、实现。 这些分别是什么，以及有什么区别，请看我之前的文章。
计算机系统结构的概念
计算机的组成和实现以及它们之间的关系
这里简单概括一下。
 计算机系统结构又称计算机层次结构，是传统机器级的系统结构。它是软硬件的交界面 它研究的内容是   传统机器级上界面的定义。 软硬件功能的分配。 为各机器级提供应有应遵循的规范。   计算机组成 是计算机系统结构逻辑的实现，包括内部控制流，数据流的组成，逻辑设计等。
  计算机实现 是计算机组成的物理实现，它主要研究 器件技术 和 微组装技术 。以器件技术为主导。
  计算机设计的主要方法 计算机设计的主要方法有三种。分别是 从上往下，从下往上，从中间向两边。第三种方法为目前最佳的设计方式。
从上往下 也称“从顶向低”设计。
它的方法为：
先考虑满足应用要求，定好面向应用的那个虚拟机器级的特性和环境，在逐级向下设计。
它的特点为：
 每设计下一级，都要考虑对下一级的优化。【优化问题】 要串行设计，设计周期长。【设计效率】 通用机的应用对象和环境不停改变，一旦改变，软硬件很快就会不适应，系统效率极具下降。【应用易改变】 其传统机器级和微程序机器级，都在已有机器中选型。通常不专门设计。【不专门设计】 实际很难做到面向应用优化。【难优化】  从下往上 也称 “由底向顶”设计。
方法：先不管应用要求，按照已有机器的特点来做器件，将传统机器机器级和微程序机器级研发。然后适配不同领域的操作系统和编译系统软件，采用合适的系统软件和算法来满足应用需求。
特点：
 硬件不能改变，仅靠设计软件来被动适配硬件。有时候仅仅需要稍微更改或增加硬件的功能就能大大简化软件设计，都做不到。【硬件不可变】 软硬件脱节，软件得不到硬件的支持而变得繁杂，部分机器指标不真实。【软硬件脱节】 串行设计，会延长设计周期。同样已经很少使用。【设计周期长】  由中间开始 方法：由中间开始向两边设计。
这是通用机通常使用的方法。</description>
    </item>
    
    <item>
      <title>计算机系统软硬件取舍与定量设计1.3</title>
      <link>https://itscola.github.io/blog/4.computersystemframework-1.3/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/4.computersystemframework-1.3/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
计算机系统软硬件取舍与定量设计  计算机的功能可以通过硬件实现，也可以通过软件实现。但不存在纯硬件实现或纯软件实现的计算机。
 这意味着什么？ 意味着在设计一台计算机时，功能即可以使用软件实现，又可以使用硬件实现。它们的使用边界变得模糊。 这是要讲的 软硬件取舍
在设计一台计算机时，我们要怎么样做，才能做到好？ 我们需要一些依据，来帮助更好的设计。 这是要讲的 定量设计原理
以及作为使用者，该如何判断一个计算机到底如何？ 这是要讲的 计算机性能描述（使用者角度）
一 软硬件取舍 1. 成本方面考虑 作为计算机设计者，成本是一个很重要的方面。它包括了软硬件的 设计成本 和 制造成本。
根据我曾经的文章 (这里不再重复解释，请先去看这篇文章)
软件实现和硬件实现的比例关系与推导过程
我们可以得知：
 用软件来实现更灵活，更强大，设计和重复生产费用更低。但效率远不如硬件实现。 用硬件实现效率更高，性能更高，但设计和生产费用较为高昂，灵活性不如软件。 硬件对研发与制造费用极其高，费用为软件的100倍是完全可能的。  以及结论：
 也就是说 一个功能 经常用到 经常出现 才更适合用硬件。 当我们要生产的设备产量越大，我们用硬件的比例就可以越多(越适合)。 并不是用硬件实现功能的比列越大越好。这还要考虑资金等问题。  2. 取舍基本原则 加上成本方面与其它方面，可以有以下几点取舍原则。
  在现有硬、器件条件下，应从实现费用，速度，其它性能性能 综合考虑，以获得高的性能价格比。【性能价格比】 应考虑采用或可能采用组成技术，使其不要过多或不合理地限制各种实现和组成技术。【组成技术】 不能光从“硬”的角度去考虑如何便于应用组成技术的成功 和 发挥器件技术的发展，还要从“软”的角度把 如何为 编译和操作系统的实现 以及 高级语言程序的设计 提供更多，更好的硬件支持 放在首位。【兼容度】   第一点是，要从费用、速度、其它性能综合考虑获得性价比。</description>
    </item>
    
    <item>
      <title>阿姆达尔定律(计算机加速比)</title>
      <link>https://itscola.github.io/blog/amdhallaw/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/amdhallaw/</guid>
      <description>阿姆达尔定律(计算机加速比) 当我们通过改进计算机来对计算机进行加速时，究竟加速了多少？
我们对计算机的部分硬件进行重量级提升，花费大量资金，但计算机性能并没有显著提升，这是为什么？
这就是这篇文章要讲的话题，阿姆达尔定律。
阿姆达尔定律的背景 阿姆达尔定律 由 阿姆达尔在1967年提出。他是IBM360系列机的主要设计者。
定理可以确定对系统中性能难以提升的部分改进后的改进程度。
整个定律由数学公式计算，具有一定参考价值。从定律中，也可以得到一些对计算机改进方面的结论。
也许现实中并不好测量然后计算，但它带给我们的结论才是最重要的。
阿姆达尔定律的推导过程 提示：如果对推导过程不感兴趣，可以直接看结论。
第一点，要知道的是。
加速比 = 系统改进后的性能 / 系统改进前的性能 = 改进前的总执行时间 / 改进后的总执行时间
看不懂？ 那就对了，我们继续往下。
第二点要知道的是：
改进前￼的总执行时间 = 不可改进部分的执行时间 + 可改进部分的执行时间
改进后的总执行时间 = (1 - 可改进比例) * 总执行时间 + (可改进比例 * 总执行时间)/部件加速比
 首先，我们改进一个机器，通常不是全部改进，而是只改进一部分。所以有了可改进比例 和 不可改进比例。
那么来看第二条，
我们的可改进比例有了，那不可改进比例呢？ 是不是就是 1 - 可改进比例。
再来看 (可改进比例 * 总执行时间) / 部件加速比
这个 部件加速比 是什么？
我们试着去掉它 得到
(可改进比例 * 总执行时间)
一目了然了，去掉后就是 我们改进前的 可改进部分的总执行时间 。</description>
    </item>
    
  </channel>
</rss>
