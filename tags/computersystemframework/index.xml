<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ComputerSystemFramework on White_cola Blog</title>
    <link>https://itscola.github.io/tags/computersystemframework/</link>
    <description>Recent content in ComputerSystemFramework on White_cola Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>志存高远 , 以梦为马.</copyright>
    <lastBuildDate>Mon, 26 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://itscola.github.io/tags/computersystemframework/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[1.4]应用 器件 的发展对系统结构的影响1.4-2</title>
      <link>https://itscola.github.io/blog/7.computersystemframework-1.4-2/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/7.computersystemframework-1.4-2/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
应用发展对计算机系统的影响 应用的需求时计算机发展的最大动力。
（没有应用需求，很难有动力）
由于需求，计算机系统结构才不断地提高性能。
需求：
多媒体：大型游戏，高清视频 网络应用：云计算，防火墙，高性能路由器 科学计算：机器学习，天气预报
其中大型游戏是促进个人电脑更新换代的最大动力。
器件发展对系统结构的影响 1. 非用户片，现场片，用户片 的定义。 非用户片：
也称“通用片”，其功能是由器件厂家生产时固定的，器件的用户只能使用，不能更改器件的内部功能。
现场片：
用户可根据需求更改器件内部功能。在20世纪70年代中期出现。使用灵活，功能强，可取代硬联组合网络，还可以构成时序网络。
如：可编程只读储存器PROM（BIOS所用）、现场可编程逻辑阵列FPLA等。
用户片：
专门按照用户要求，生成高集成度VLSI器件。 设计周期长，设计费用高，销量小，成本高。
（如果是完全按照需求设计的用户片，称为全用户片。）
苹果公司直呼内行
2. 器件发展是推动系统结构和组成前进的因素 电子管 -&amp;gt; 晶体管 -&amp;gt; 小规模集成电路 -&amp;gt; 大规模集成电路 -&amp;gt; 超大规模集成电路
非用户片 -&amp;gt; 现场片 -&amp;gt; 用户片
制造工艺也在进步。
国外的光刻机是好几个国家联合研发的。但它们不愿意卖给我们国家。我们必须研发自己的光刻机。这对我们国家的未来真的十分重要。尽管非常非常艰难。
工艺越强大 ：集成度上升 功耗下降 主频上升 性能上升。
3. 器件发展改变了逻辑设计的方法 过去的设计逻辑：专注逻辑简化 和 各种节省。（节省功耗、降低成本、提高速度） （对现在的VLSI不适应）
VLSI是超大规模集成电路(Very Large Scale Integration)的简称
目前的设计逻辑：
最主要是应用。（微汇编，微高级语言，计算机辅助设计软件的方法来设计）
对于用户片的计算机 ，机器设计 和 芯片设计 密不可分，机器设计的关键是芯片设计。</description>
    </item>
    
    <item>
      <title>[1.4]软件的发展对系统结构的影响1.4-1</title>
      <link>https://itscola.github.io/blog/6.computersystemframework-1.4-1/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/6.computersystemframework-1.4-1/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
软件的发展对系统结构的影响 软件发展对系统结构的影响，主要体现在可移植性方面。
1. 软件的可以移植性 可移植性的概念：一款程序不经修改，或只需要少量的修改，就可以由一台计算机移植到另一台计算机。同一软件应用于不同环境。
一台计算机移植到另一台计算机，不经修改，或修改的很少，我们就说 可移植性 越好。反之 越差。
每次发布新硬件，都要考虑可移植性，可移植性越高越好。
假如我发布了一个显卡，性能比市面上显卡性能普遍较高，但是显卡的 可移植性很差，不兼容市面上所有程序。也就是说程序完全需要从0设计。 通常是不会有生命力的。
2. 可移植性特点  软件能长期使用，不会因为机器更新需要重新编写。 大大减少了编程软件的工作量。 能迅速用上新的硬件技术，更新系统，让新系统立即发挥效能。 软件设计者将更有精力开发全新的软件。  实现可移植性的几种方法 实现可移植性主要有三种方法。
1. 统一高级语言 统一高级语言，是一种理想的软件移植方法。
让所有程序员使用统一的高级语言，这样只需要各个操作系统对这种语言适配（操作系统的全部或一部分使用这种语言），即可实现软件的高可移植性。
但直到如今，没有一种是对各种应用真正通用的高级语言。
又很多语言去尝试，比如跨平台比较优秀的 haxe语言，它可以编译成Java，CPP，JavaScript，C#，JVM，PHP，Python&amp;hellip;&amp;hellip; 。以及几乎支持所有常见平台。实现真正跨平台。但目前还是小众语言，原因也如下列所说。 Haxe - Github
原因如下：
（如果理解加粗字体，就可以不用看后面的内容）
  不同用途要求语言语法不同，如Julia语言面向科学计算，Java面向程序开发。它们的语义语法结构，差异较大。难以统一。 如果强制去统一，语言又会变得难以掌握，编译程序较大，编译效率低。
  人们对语言基础结构看法不同，如 有的人觉着GOTO语句能让语言更灵活 应该保留。而有的人觉着它会降低代码可读性 应取消。
  **即使同一种高级语言在不同厂家的机器上也不能完全通用。**各厂家机器的 I/O设备种类和数量，子程序结构，寻址空间，操作系统等 并不相同。 部分厂家为发展自己特色，常用自己的 “专有语言” 。为节省储存空间，提高执行速度，在高级语言软件中部分嵌入汇编语言，使同种高级语言难以移植。
  语言习惯问题，人们不愿意抛弃自己习惯的语言，不愿意抛弃自己长期积累的经验 和 在原有语言编写已被实践证明正确的软件。
  为此，各种机器都得适配较多通用的高级语言编译系统。同一种高级语言，各个机器的编译系统软件不同，无法通用，不利于系统结构的发展</description>
    </item>
    
    <item>
      <title>计算机系统设计的主要任务和方法1.3(Addition)</title>
      <link>https://itscola.github.io/blog/5.computersystemframework-1.3addition/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/5.computersystemframework-1.3addition/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
计算机系统设计的主要任务和方法 知道了计算机系统的层次结构，知道了机器级。这篇文章，将基于 机器级分层原理 来讲述 计算机系设计的方法。
主要任务 计算机系统设计的主要任务包括 系统结构、组成、实现。 这些分别是什么，以及有什么区别，请看我之前的文章。
计算机系统结构的概念
计算机的组成和实现以及它们之间的关系
这里简单概括一下。
 计算机系统结构又称计算机层次结构，是传统机器级的系统结构。它是软硬件的交界面 它研究的内容是   传统机器级上界面的定义。 软硬件功能的分配。 为各机器级提供应有应遵循的规范。   计算机组成 是计算机系统结构逻辑的实现，包括内部控制流，数据流的组成，逻辑设计等。
  计算机实现 是计算机组成的物理实现，它主要研究 器件技术 和 微组装技术 。以器件技术为主导。
  计算机设计的主要方法 计算机设计的主要方法有三种。分别是 从上往下，从下往上，从中间向两边。第三种方法为目前最佳的设计方式。
从上往下 也称“从顶向低”设计。
它的方法为：
先考虑满足应用要求，定好面向应用的那个虚拟机器级的特性和环境，在逐级向下设计。
它的特点为：
 每设计下一级，都要考虑对下一级的优化。【优化问题】 要串行设计，设计周期长。【设计效率】 通用机的应用对象和环境不停改变，一旦改变，软硬件很快就会不适应，系统效率极具下降。【应用易改变】 其传统机器级和微程序机器级，都在已有机器中选型。通常不专门设计。【不专门设计】 实际很难做到面向应用优化。【难优化】  从下往上 也称 “由底向顶”设计。
方法：先不管应用要求，按照已有机器的特点来做器件，将传统机器机器级和微程序机器级研发。然后适配不同领域的操作系统和编译系统软件，采用合适的系统软件和算法来满足应用需求。
特点：
 硬件不能改变，仅靠设计软件来被动适配硬件。有时候仅仅需要稍微更改或增加硬件的功能就能大大简化软件设计，都做不到。【硬件不可变】 软硬件脱节，软件得不到硬件的支持而变得繁杂，部分机器指标不真实。【软硬件脱节】 串行设计，会延长设计周期。同样已经很少使用。【设计周期长】  由中间开始 方法：由中间开始向两边设计。
这是通用机通常使用的方法。</description>
    </item>
    
    <item>
      <title>向下兼容 向上兼容 向前兼容 向后兼容</title>
      <link>https://itscola.github.io/blog/updownbeforeafter/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/updownbeforeafter/</guid>
      <description> 向下兼容 向上兼容 向前兼容 向后兼容 有没有听说过，向后兼容？ 其实有向“前后上下”兼容。 其实这些概念很简单。
向上兼容（基本要求） 向上兼容是指，当我们在一个计算机上开发程序，然后换了台（同一系列）性能更好，档次更高的计算机。然后程序依然能兼容（完美运行）。
向上兼容：在低档次计算机开发的程序，在高档次计算机依然兼容。
向上兼容是开发一个程序的必要要求。
向下兼容 向下兼容则和向上兼容相反，当我们在一个计算机上开发程序，换了台（同一系列）低性能、低档次的计算机，程序依然能兼容。（完美运行）。
向下兼容：在高档次计算机开发的程序，在低档次计算机依然兼容。
向前兼容 向前兼容是指，假如我在2021年出的计算机上开发一个程序。在2018年的计算机上依然兼容（完美运行）。
向前兼容：在一台计算机上开发的程序，在之前的计算机依然兼容。
向后兼容（基本要求） 向后兼容是指，假如我在2018年出的计算机上开发一个程序。在2020年的计算机上依然兼容（完美运行）。
向前兼容：在一台计算机上开发的程序，在之后的计算机依然兼容。
向后兼容是开发一个程序的必要要求。
总结  向前兼容，向后兼容 指的是时间前后兼容问题。 向上兼容，和向上兼容 指的是计算机档次兼容问题。 向上兼容和向后兼容比较容易做到。这也是程序开发的基本要求。（特别是向后兼容）  </description>
    </item>
    
    <item>
      <title>计算机系统软硬件取舍与定量设计1.3</title>
      <link>https://itscola.github.io/blog/4.computersystemframework-1.3/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/4.computersystemframework-1.3/</guid>
      <description>要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列会以我自己理解的方式，分享我在学习 计算机系统结构 过程中，所获得的知识。
这个系列并不是普通的“笔记”，不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
计算机系统软硬件取舍与定量设计  计算机的功能可以通过硬件实现，也可以通过软件实现。但不存在纯硬件实现或纯软件实现的计算机。
 这意味着什么？ 意味着在设计一台计算机时，功能即可以使用软件实现，又可以使用硬件实现。它们的使用边界变得模糊。 这是要讲的 软硬件取舍
在设计一台计算机时，我们要怎么样做，才能做到好？ 我们需要一些依据，来帮助更好的设计。 这是要讲的 定量设计原理
以及作为使用者，该如何判断一个计算机到底如何？ 这是要讲的 计算机性能描述（使用者角度）
一 软硬件取舍 1. 成本方面考虑 作为计算机设计者，成本是一个很重要的方面。它包括了软硬件的 设计成本 和 制造成本。
根据我曾经的文章 (这里不再重复解释，请先去看这篇文章)
软件实现和硬件实现的比例关系与推导过程
我们可以得知：
 用软件来实现更灵活，更强大，设计和重复生产费用更低。但效率远不如硬件实现。 用硬件实现效率更高，性能更高，但设计和生产费用较为高昂，灵活性不如软件。 硬件对研发与制造费用极其高，费用为软件的100倍是完全可能的。  以及结论：
 也就是说 一个功能 经常用到 经常出现 才更适合用硬件。 当我们要生产的设备产量越大，我们用硬件的比例就可以越多(越适合)。 并不是用硬件实现功能的比列越大越好。这还要考虑资金等问题。  2. 取舍基本原则 加上成本方面与其它方面，可以有以下几点取舍原则。
  在现有硬、器件条件下，应从实现费用，速度，其它性能性能 综合考虑，以获得高的性能价格比。【性能价格比】 应考虑采用或可能采用组成技术，使其不要过多或不合理地限制各种实现和组成技术。【组成技术】 不能光从“硬”的角度去考虑如何便于应用组成技术的成功 和 发挥器件技术的发展，还要从“软”的角度把 如何为 编译和操作系统的实现 以及 高级语言程序的设计 提供更多，更好的硬件支持 放在首位。【兼容度】   第一点是，要从费用、速度、其它性能综合考虑获得性价比。</description>
    </item>
    
    <item>
      <title>阿姆达尔定律(计算机加速比)</title>
      <link>https://itscola.github.io/blog/amdhallaw/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/amdhallaw/</guid>
      <description>阿姆达尔定律(计算机加速比) 当我们通过改进计算机来对计算机进行加速时，究竟加速了多少？
我们对计算机的部分硬件进行重量级提升，花费大量资金，但计算机性能并没有显著提升，这是为什么？
这就是这篇文章要讲的话题，阿姆达尔定律。
阿姆达尔定律的背景 阿姆达尔定律 由 阿姆达尔在1967年提出。他是IBM360系列机的主要设计者。
定理可以确定对系统中性能难以提升的部分改进后的改进程度。
整个定律由数学公式计算，具有一定参考价值。从定律中，也可以得到一些对计算机改进方面的结论。
也许现实中并不好测量然后计算，但它带给我们的结论才是最重要的。
阿姆达尔定律的推导过程 提示：如果对推导过程不感兴趣，可以直接看结论。
第一点，要知道的是。
加速比 = 系统改进后的性能 / 系统改进前的性能 = 改进前的总执行时间 / 改进后的总执行时间
看不懂？ 那就对了，我们继续往下。
第二点要知道的是：
改进前￼的总执行时间 = 不可改进部分的执行时间 + 可改进部分的执行时间
改进后的总执行时间 = (1 - 可改进比例) * 总执行时间 + (可改进比例 * 总执行时间)/部件加速比
 首先，我们改进一个机器，通常不是全部改进，而是只改进一部分。所以有了可改进比例 和 不可改进比例。
那么来看第二条，
我们的可改进比例有了，那不可改进比例呢？ 是不是就是 1 - 可改进比例。
再来看 (可改进比例 * 总执行时间) / 部件加速比
这个 部件加速比 是什么？
我们试着去掉它 得到
(可改进比例 * 总执行时间)
一目了然了，去掉后就是 我们改进前的 可改进部分的总执行时间 。</description>
    </item>
    
    <item>
      <title>软件实现和硬件实现的比例关系与推导过程</title>
      <link>https://itscola.github.io/blog/softwareandhardwareimplenment/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/softwareandhardwareimplenment/</guid>
      <description>软件实现和硬件实现的比例关系 通常，同一个功能，我们既可以用软件实现也可以用硬件来实现。
用软件来实现更灵活，更强大，设计和重复生产费用更低。但效率远不如硬件实现。
用硬件实现效率更高，性能更高，但设计和生产费用较为高昂，灵活性不如软件。
（通常不存在只用软件实现或只用硬件实现的类计算机设备）
通过这篇文章，你将了解到，计算机 手机 设备 等设计 软硬件取舍，以及设备产量与硬件费用的关系。
（生产量越多，设备在一定资金下，能用的硬件越多？）
生产软硬件分别需要支付的费用 生产软硬件 都需要 研发费用(Design) 和 生产费用(Manufacture)。
软件通常需要多次设计(研发)，硬件通常只需要设计一次。
我们设硬件每次的研发费用为D(hardware) 简称 D(h). 同时设每次重复生产费用为M(h)。
设软件研发每次的研发费用为 D(software) 简称 D(s). 同时设每次重复生产费用为 M(s)。
D(h) 约等于 100D(s). 每研发一个硬件的费用 大概为 研发100个软件的费用。 M(h)约等于 100M(h). 每生产一个硬件的费用 大概为 生产100个软件的费用。
(可以说硬件和软件比 是非常贵的。)
实际生产费用 我们设生产了V个设备，同时设研发了C次。
设一个功能在一台设备上出现了R次。
每台设备的软件生产费用 那么每台设备 软件实际生产费用为 C * D(s) / V + R * M(s).
指的是 研发次数 * 研发软件费用 / 设备生产数 + 功能在设备上出现次数 * 软件重复生产费用
每台设备的硬件生产费用 那么每台设备 硬件实际生产费用为</description>
    </item>
    
    <item>
      <title>计算机的组成和实现以及它们之间的关系1.2.2</title>
      <link>https://itscola.github.io/blog/3.computersystemframework-1.2.2/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/3.computersystemframework-1.2.2/</guid>
      <description> A. 计算机系统结构 组成 和 实现 2 要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列并不是普通的“笔记”，而是以我个人的理解，来讲解 计算机系统结构。 不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
1. 计算机组成 1. 什么是计算机组成 计算机组成就是 计算机系统结构 的逻辑实现。 包括机器级内部的控制流 数据流的组成 逻辑设计等。
 着眼于机器级内部各事件的排序方式，控制结构，各部件的功能及其联系。
 比如要处理一个事件，事件的处理顺序，方式 （逻辑）。这都属于计算机组成。
计算机组成对于系统结构来说是透明的，
2. 计算机组成的研究 它要研究的是：如何在一定资金和性能下，做到更好更合理的组成计算机，实现所需的系统结构。
2. 计算机实现 1. 什么是计算机实现 计算机实现是计算机组成的物理实现。
电路怎么设计，采用什么工艺制作，器件集成度和速度 ，模块底板的划分和连接 &amp;hellip;&amp;hellip; 这都属于 计算机实现。（主要是一些能看得到摸得着的东西）
计算机的实现对于计算机系统结构来说也是透明的。
2. 计算机实现的研究（着眼于） 它主要着眼于 器件技术 和 微组装技术，
其中器件技术起主导地位。
3. 计算机系统结构，组成，实现的互相关系和影响 1. 相互关系  它们互不相同，却互相影响。 相同结构的计算机，可以有多种组成方式。 相同组成的计算机，可以有多种实现方式。  （就比如系统结构相同，但是逻辑实现并不一定相同。比如相同的系统，当随着版本更新，实现逻辑可能有变化）
（又比如逻辑实现相同，但是物理实现可能不同。比如芯片制作工艺不一样。）
2. 相互影响  计算机组成向上决定于 计算机系统结构 ，向下受限于实现技术。 应当在所需条件下，应在计算机组成 和 实现之间做权衡。 组成也会影响结构，没有计算机组成的进步，就没有计算机系统结构的进步。 计算机系统结构不但要考虑上级的算法，软件，界面 支持。还要考虑下级的可能采用和准备采用的组成和实现技术。 不同时期不同系统，结构，组成，实现之间也有差异。在某些系统中作为结构的内容，在另一些系统中可能是组成和实现技术的内容。  </description>
    </item>
    
    <item>
      <title>计算机系统结构的概念1.2.1</title>
      <link>https://itscola.github.io/blog/2.computersystemframework-1.2.1/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/2.computersystemframework-1.2.1/</guid>
      <description>A. 计算机系统结构 和 组成 和 实现 1 要看懂本篇文章，你可能需要先看之前的文章。这是一个系列，讲解计算机系统结构。 如果你正在学这门科目，那这个系列将非常适合你。
这个系列并不是普通的“笔记”，而是以我个人的理解，来讲解 计算机系统结构。 不同的是，我会用尽可能简洁通俗的语言来讲解。
计算机系统结构系列
1. 什么是计算机系统结构 1. 透明性 先要清楚一个概念，什么是透明性？
透明性： 一些客观存在的属性或事物，在某个角度看不到，那么就说那些属性或事物对于这个角度是透明的。
举个例子：我们在使用操作系统时，我们是看不到 组成这台计算机的零件 是如何运作的。
可以说 “组成这台计算机的零件 是如何运作的”对于我们从使用操作系统这个角度，是透明的。
2. 透明性的作用 理解了透明性，那大概能猜出这样的作用了。
 简化所在机器级的设计。(好处) 透明也会带来一些无法控制的问题。(坏处)  我们在一个角度上，不怎么需要太在意对我们透明的事物属性。这大大简化了我们的使用。
但是有时候，我们在一个角度上，必须要在意对我们透明的事物属性，这会给我们带来不利。这也是无法控制的问题。
3. 系统结构 及其研究 在研究计算机系统结构前，先来了解下什么是 系统结构。
系统结构：以计算机系统结构的角度说，系统结构指的是，计算机系统中 各机器级界面的定义 以及上下功能的分配。
什么意思？ 各机器级上的界面，定义为什么。 上下级功能分配了什么。我们将这 定义 分配 称为系统结构。
系统结构的研究： 在定义 和 分配时 我们要对 某些事物属性进行划分。哪些属于这里，哪些属于那里。换言说，我们就是在 研究 哪些属性应该透明，哪些属性不应该透明。
4. 计算机系统结构 及其研究 概念： 计算机系统结构 是 系统结构 的一部分。
它又被称为 计算机系统的结构体系。 它指的就是 传统机器语言机器级 的系统结构。</description>
    </item>
    
    <item>
      <title>计算机系统层次结构1.1</title>
      <link>https://itscola.github.io/blog/1.computersystemframework-1/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://itscola.github.io/blog/1.computersystemframework-1/</guid>
      <description>A.计算机系统层级结构 这一篇，来说下计算机的 基础理论知识。
它属于计算机系统结构的内容. 关于计算机系统结构，可能会做一个系列。
一. 计算机系统的层次 1. 概念 通用计算机系统层次 分为6个级，每个级我们称之为 “机器级”。 距离人的使用越近的，越为高级，反之，越远，越为低级。
从高级到低级，分别有 应用语言机器级，高级语言机器级，汇编语言机器级，操作系统机器级，传统机器语言机器级，微程序机器级。
记得有张图，有个大学教授问“vscode是什么语言？”，引起很多人“嘲讽”。 我认为它大概问的就是机器级。 应回答 “应用语言”。
2. 分机器级的意义 透明的概念：在分级的情况下，任意一级(有下一级的情况下)的下级，对于这级通常都是不必太关心的。但下级是客观存在的。我们就说,对于这一级,那些下一级都是透明的.
举个例子：我们要用java语言开发一个程序，我们通常不需要在乎，这个电脑用的什么显卡，用的什么主板，用的什么处理方式。 这些对于我们来说都是透明的。
二.机器级的实现 1.实现的两种方式 机器级等实现主要通过两种方式。
翻译 或 解释 或是 解释翻译 并用。
翻译技术：先用转换器，将上一级机器级的程序翻译为下一级等效的程序。然后在下一级机器级继续实现。
举个例子：C语言程序会由编译程序翻译成汇编程序，汇编程序由汇编器翻译成机器语言程序。
解释技术：用第一级的机器级上的一串语句或指令来仿真高级机器级的一条语句，或指令功能。（运行过程中 逐条逐句的解释）
例子：JavaScript由浏览器解释执行，如果有错误，通常不会影响到前面的代码。
2.翻译和解释的特点  翻译往往是所有程序做完再执行，而解释是一边解释一边执行。 解释过程中 解释一条 运行一条 灵活性更高。  什么是编译器,解释器? (一文理解编译型和解释型语言)
3.机器级间的特点  应用语言 程序通过程序包翻译成高级语言程序。 高级语言 程序通过编译程序编译成汇编语言程序。（或是 中间代码，再或是 机器语言程序） 汇编语言 程序通过汇编程序翻译成机器语言程序。 操作系统 通过机器语言程序 解释 控制语句作业。 传统机器机器级由 微程序(固件) 实现。 而前四个都由软件实现。  固件是指通过硬件实现软件功能。 如常见的BIOS ，它通常不会改变，但又不是不可改变。</description>
    </item>
    
  </channel>
</rss>
